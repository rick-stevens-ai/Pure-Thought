\documentclass[11pt,a4paper]{article}

% Packages
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[english]{babel}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{mathtools}
\usepackage{physics}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{tocloft}
\usepackage{enumitem}
\usepackage{booktabs}
\usepackage{algorithm}
\usepackage{algpseudocode}

% Page geometry
\geometry{
    a4paper,
    left=25mm,
    right=25mm,
    top=30mm,
    bottom=30mm,
}

% Header and footer
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{Pure Thought Challenge 17}
\fancyhead[R]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}

% Hyperref setup
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    citecolor=blue,
    urlcolor=blue,
    pdfauthor={Pure Thought AI Challenges},
    pdftitle={PRD 17: Isomer Enumeration via Molecular Graph Theory},
}

% Code listing style
\definecolor{codegray}{rgb}{0.95,0.95,0.95}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codepurple}{rgb}{0.58,0,0.82}

\lstdefinestyle{pythonstyle}{
    language=Python,
    backgroundcolor=\color{codegray},
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\small,
    breaklines=true,
    breakatwhitespace=true,
    captionpos=b,
    frame=single,
    numbers=left,
    numberstyle=\tiny\color{gray},
    tabsize=4,
    showstringspaces=false,
}

\lstset{style=pythonstyle}

% Theorem environments
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}
\theoremstyle{remark}
\newtheorem{remark}[theorem]{Remark}

% Custom commands
\newcommand{\checklist}[1]{\item[$\square$] #1}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\N}{\mathbb{N}}

% Title information
\title{\textbf{PRD 17: Isomer Enumeration via Molecular Graph Theory} \\
\large Pure Thought AI Challenge 17}
\author{Pure Thought AI Challenges Project}
\date{\today}

\begin{document}

\maketitle
\thispagestyle{empty}

\begin{abstract}
This document presents a comprehensive Product Requirement Document (PRD) for implementing a pure-thought computational challenge. The problem can be tackled using only symbolic mathematics, exact arithmetic, and fresh code---no experimental data or materials databases required until final verification. All results must be accompanied by machine-checkable certificates.
\end{abstract}

\clearpage
\tableofcontents
\clearpage


\textbf{Domain}: Chemistry & Combinatorics

\textbf{Timeline}: 4-6 months

\textbf{Difficulty}: Medium-High

\textbf{Prerequisites}: Graph theory, group theory (Pólya enumeration), combinatorial optimization, SAT solving



\bigskip\hrule\bigskip


\subsection{1. Problem Statement}


\subsubsection{Scientific Context}

\textbf{Isomers} are molecules with the same chemical formula but different atomic arrangements. Enumerating all isomers for a given formula is a fundamental problem in chemistry:


\textbf{Types of Isomers}:

\begin{itemize}
\item \textbf{Structural isomers}: Different connectivity graphs (e.g., butane vs isobutane: both C₄H₁₀)

\item \textbf{Stereoisomers}: Same connectivity, different 3D spatial arrangement

\item \textbf{Conformers}: Same structure, different rotations around single bonds


\end{itemize}

\textbf{Challenges}:

\begin{itemize}
\item Number of isomers grows exponentially with molecular size

\item Chemical valence rules constrain graphs (C forms 4 bonds, O forms 2, H forms 1)

\item Symmetry: many graphs are equivalent up to atom relabeling (automorphisms)


\end{itemize}

\textbf{Current Methods}:

\begin{itemize}
\item \textbf{Brute force}: Generate all graphs, filter by valence—combinatorial explosion

\item \textbf{Chemical databases}: Enumerate known structures—incomplete for large molecules

\item \textbf{SMILES enumeration}: String-based, but misses many structures


\end{itemize}

\textbf{Pure Thought Approach}:

\begin{itemize}
\item Use \textbf{P 19th century mathematician György Pólya's enumeration theorem} to count distinct graphs

\item Generate isomers systematically using \textbf{canonical labeling} (avoids duplicates)

\item Apply chemical constraints as \textbf{SAT/SMT problems}

\item Certify completeness: prove all isomers found



\subsubsection{Core Question}

\end{itemize}

\textbf{Can we enumerate ALL isomers for a molecular formula C\textit{x H}y O_z... using ONLY graph theory and combinatorial algorithms—without chemistry databases or heuristics?}


Specifically:

\begin{itemize}
\item Given formula (e.g., C₆H₁₂O), generate all structurally distinct molecular graphs

\item Apply valence constraints (C: 4, O: 2, N: 3, H: 1)

\item Remove duplicate graphs via canonical labeling (nauty algorithm)

\item Verify completeness: prove no isomers missed

\item Extend to stereoisomers (chirality, E/Z isomerism)

\item Export as SMILES strings + 3D geometries



\subsubsection{Why This Matters}

\end{itemize}

\textbf{Theoretical Impact}:

\begin{itemize}
\item Connects pure combinatorics to molecular chemistry

\item Provides exact enumeration (no sampling or approximation)

\item Algorithmic chemistry: automated structure generation


\end{itemize}

\textbf{Practical Benefits}:

\begin{itemize}
\item Drug discovery: enumerate all possible drug candidates with formula

\item Materials design: explore chemical space systematically

\item Retrosynthesis: identify alternative synthetic routes


\end{itemize}

\textbf{Pure Thought Advantages}:

\begin{itemize}
\item Valence rules are purely graph-theoretic

\item Pólya theory provides exact counts

\item No experimental data needed

\item Certificates of completeness via SAT solvers



\bigskip\hrule\bigskip


\subsection{2. Mathematical Formulation}


\subsubsection{Problem Definition}

\end{itemize}

A \textbf{molecular graph} is G = (V, E) where:

\begin{itemize}
\item V = vertices (atoms)

\item E = edges (bonds), with multiplicities (single, double, triple)


\end{itemize}

\textbf{Valence constraint}: Each atom v has degree deg(v) = valence(element(v))

\begin{itemize}
\item C: deg = 4

\item O: deg = 2

\item N: deg = 3

\item H: deg = 1


\end{itemize}

Counting bond multiplicity:

\begin{lstlisting}
deg(v) = Σ_{u ∈ neighbors(v)} bond_order(v, u)
\end{lstlisting}

\textbf{Isomer Enumeration Problem}:

\begin{lstlisting}
Input: Molecular formula {n_C carbons, n_H hydrogens, n_O oxygens, ...}
Output: Set S of non-isomorphic connected molecular graphs satisfying valence constraints
\end{lstlisting}

\textbf{Isomorphism}: Two graphs G₁, G₂ are isomorphic if there exists bijection φ: V₁ → V₂ preserving adjacency and atom types.


\textbf{Certificate}: For each isomer G ∈ S:

\begin{itemize}
\item \textbf{Valence check}: ∀v, deg(v) = valence(v)

\item \textbf{Canonicity}: G is in canonical form (no other isomorphic graph generated)

\item \textbf{Completeness proof}: All graphs in S are non-isomorphic + no missing isomers



\subsubsection{Pólya Enumeration Theorem}

\end{itemize}

For counting up to symmetry:

\begin{lstlisting}
N = (1/|G|) Σ_{g ∈ G} cycle_index(g)
\end{lstlisting}

where G is the symmetry group, and cycle_index counts fixed points under each symmetry.



\subsubsection{Input/Output Specification}

\textbf{Input}:

\begin{lstlisting}
from typing import Dict
import networkx as nx

class MolecularFormula:
    elements: Dict[str, int]  # {'C': 4, 'H': 10} for C₄H₁₀

    # Optional constraints
    allow_double_bonds: bool = True
    allow_triple_bonds: bool = False
    allow_rings: bool = True
    max_ring_size: int = 8
\end{lstlisting}

\textbf{Output}:

\begin{lstlisting}
class IsomerCertificate:
    formula: MolecularFormula

    # Enumerated isomers
    isomers: List[nx.Graph]  # List of molecular graphs
    num_isomers: int

    # Canonical representations
    canonical_smiles: List[str]  # SMILES strings
    adjacency_matrices: List[np.ndarray]

    # Verification
    pólya_count: int  # Theoretical count from Pólya theorem
    completeness_proof: str  # SAT/SMT certificate

    # Statistics
    num_with_rings: int
    num_with_double_bonds: int
    degree_distribution: Dict[int, int]

    # Export
    mol_files: List[Path]  # 3D structures (.mol, .xyz)
    smiles_file: Path
\end{lstlisting}


\bigskip\hrule\bigskip


\subsection{3. Implementation Approach}


\subsubsection{Phase 1: Simple Enumeration for Small Molecules (Month 1)}

Implement brute-force for validation:


\begin{lstlisting}
import networkx as nx
from itertools import combinations
from typing import List

VALENCES = {'C': 4, 'H': 1, 'O': 2, 'N': 3, 'S': 2, 'P': 3, 'F': 1, 'Cl': 1}

def generate_all_graphs_brute_force(formula: MolecularFormula) -> List[nx.Graph]:
    """
    Brute force: try all possible connectivity patterns.

    Only works for very small molecules (≤ 10 atoms).
    """
    # Create vertex list
    atoms = []
    for elem, count in formula.elements.items():
        atoms.extend([elem] * count)

    n = len(atoms)

    # All possible edge sets (choose subset of n(n-1)/2 possible edges)
    max_edges = n * (n-1) // 2
    valid_graphs = []

    # Iterate over all possible edge sets
    all_possible_edges = list(combinations(range(n), 2))

    for num_edges in range(n-1, max_edges+1):  # At least n-1 for connectivity
        for edge_set in combinations(all_possible_edges, num_edges):
            G = nx.Graph()
            G.add_nodes_from(range(n))

            # Assign atom types
            for i, atom in enumerate(atoms):
                G.nodes[i]['element'] = atom

            # Add edges (all single bonds for now)
            for (u, v) in edge_set:
                G.add_edge(u, v, bond_order=1)

            # Check valence
            if satisfies_valence(G) and nx.is_connected(G):
                valid_graphs.append(G)

    # Remove isomorphic duplicates
    unique_graphs = remove_isomorphic_duplicates(valid_graphs)

    return unique_graphs

def satisfies_valence(G: nx.Graph) -> bool:
    """Check if all atoms satisfy valence constraints."""
    for node in G.nodes:
        elem = G.nodes[node]['element']
        required_valence = VALENCES[elem]

        # Degree = sum of bond orders
        degree = sum(G[node][nbr].get('bond_order', 1) for nbr in G.neighbors(node))

        if degree != required_valence:
            return False

    return True

def remove_isomorphic_duplicates(graphs: List[nx.Graph]) -> List[nx.Graph]:
    """
    Remove isomorphic graphs using nauty canonical labeling.
    """
    from pynauty import Graph as PynautyGraph, certificate

    unique = []
    seen_certificates = set()

    for G in graphs:
        # Convert to pynauty format
        cert = compute_canonical_certificate(G)

        if cert not in seen_certificates:
            seen_certificates.add(cert)
            unique.append(G)

    return unique
\end{lstlisting}

\textbf{Validation}: Enumerate C₄H₁₀—should find 2 isomers (butane, isobutane).



\subsubsection{Phase 2: Canonical Labeling with nauty (Months 1-2)}

Use nauty algorithm for efficient isomorphism checking:


\begin{lstlisting}
from pynauty import Graph as PynautyGraph, autgrp, certificate

def canonical_label_molecular_graph(G: nx.Graph) -> str:
    """
    Compute canonical labeling using nauty.

    Returns string certificate uniquely identifying isomorphism class.
    """
    n = len(G.nodes)

    # Partition vertices by atom type (nauty requires integer colors)
    elem_to_color = {elem: i for i, elem in enumerate(set(VALENCES.keys()))}

    coloring = [elem_to_color[G.nodes[v]['element']] for v in range(n)]

    # Convert to pynauty format
    adjacency = {v: list(G.neighbors(v)) for v in G.nodes}

    pynauty_graph = PynautyGraph(
        number_of_vertices=n,
        directed=False,
        adjacency_dict=adjacency,
        vertex_coloring=[coloring]
    )

    # Compute canonical certificate
    cert = certificate(pynauty_graph)

    return str(cert)

def is_canonical(G: nx.Graph) -> bool:
    """
    Check if graph is in canonical form.

    Canonical form: relabeling that is lexicographically smallest.
    """
    cert_original = canonical_label_molecular_graph(G)

    # Try all permutations (expensive—just for validation)
    import itertools

    n = len(G.nodes)
    for perm in itertools.permutations(range(n)):
        G_perm = relabel_graph(G, perm)
        cert_perm = canonical_label_molecular_graph(G_perm)

        if cert_perm < cert_original:
            return False  # Found smaller labeling

    return True
\end{lstlisting}


\subsubsection{Phase 3: Systematic Graph Generation (Months 2-4)}

Use orderly generation (McKay's algorithm):


\begin{lstlisting}
def orderly_generation(formula: MolecularFormula) -> List[nx.Graph]:
    """
    Generate graphs in canonical (orderly) manner.

    Avoids generating isomorphic duplicates.

    Based on McKay's orderly generation algorithm.
    """
    atoms = expand_formula(formula)  # ['C', 'C', 'C', 'C', 'H', 'H', ...]
    n = len(atoms)

    isomers = []

    # Start with empty graph
    G_init = nx.Graph()
    G_init.add_nodes_from(range(n))
    for i, elem in enumerate(atoms):
        G_init.nodes[i]['element'] = elem

    # Recursively add edges in canonical order
    def generate_recursive(G, edge_candidates):
        # Check if valid molecular graph
        if is_complete_and_valid(G):
            # Check canonical
            if is_canonical_under_automorphism(G):
                isomers.append(G.copy())
            return

        # Pruning: stop if overvalent
        if has_overvalent_atom(G):
            return

        # Add next edge (in canonical order)
        for (u, v) in edge_candidates:
            if can_add_edge(G, u, v):
                G_new = G.copy()
                G_new.add_edge(u, v, bond_order=1)

                # Recursively expand
                remaining_candidates = [(i, j) for (i, j) in edge_candidates
                                       if (i, j) > (u, v)]
                generate_recursive(G_new, remaining_candidates)

    # All possible edges
    edge_candidates = list(combinations(range(n), 2))
    generate_recursive(G_init, edge_candidates)

    return isomers

def is_complete_and_valid(G: nx.Graph) -> bool:
    """
    Check if graph is a complete valid molecule.

    - All atoms satisfy valence
    - Graph is connected
    """
    if not nx.is_connected(G):
        return False

    for node in G.nodes:
        elem = G.nodes[node]['element']
        degree = G.degree(node)

        if degree != VALENCES[elem]:
            return False

    return True
\end{lstlisting}


\subsubsection{Phase 4: Pólya Enumeration (Months 4-5)}

Count isomers using Pólya's theorem:


\begin{lstlisting}
from sympy import symbols, expand, Poly
from sympy.combinatorics import PermutationGroup, Permutation

def polya_count_isomers(formula: MolecularFormula) -> int:
    """
    Use Pólya enumeration theorem to count non-isomorphic graphs.

    This gives theoretical count—doesn't enumerate structures.
    """
    atoms = expand_formula(formula)
    n = len(atoms)

    # Symmetry group: permutations preserving atom types
    # E.g., for C₄H₁₀: permutations of 4 C's × permutations of 10 H's

    C_indices = [i for i, a in enumerate(atoms) if a == 'C']
    H_indices = [i for i, a in enumerate(atoms) if a == 'H']

    # Generate symmetric group on each atom type
    perms_C = PermutationGroup([Permutation(C_indices)])
    perms_H = PermutationGroup([Permutation(H_indices)])

    # Full group: product
    G = combine_permutation_groups(perms_C, perms_H)

    # Cycle index polynomial
    x = symbols(f'x0:{n*(n-1)//2}')  # Variables for each edge

    cycle_poly = compute_cycle_index(G, x)

    # Substitute x_i → 1 + t (count graphs with/without each edge)
    t = symbols('t')
    cycle_poly_sub = cycle_poly.subs({xi: 1+t for xi in x})

    # Extract coefficient of t^m where m = number of edges
    # For tree: m = n-1
    # For general graphs with cycles: various m

    poly_expanded = expand(cycle_poly_sub)
    coeffs = Poly(poly_expanded, t).all_coeffs()

    # Number of isomers with m edges
    isomer_counts = {m: coeffs[m] for m in range(len(coeffs))}

    # Filter for chemically valid (satisfies valence)
    # This is approximate—exact filtering requires enumeration

    total_isomers = sum(isomer_counts.values())

    return total_isomers

def compute_cycle_index(G: PermutationGroup, variables: List) -> Poly:
    """
    Compute cycle index polynomial for permutation group G.

    Z(G) = (1/|G|) Σ_{g ∈ G} Π_i x_i^{c_i(g)}

    where c_i(g) = number of i-cycles in permutation g.
    """
    from sympy import Rational

    cycle_poly = 0

    for g in G.generate():
        # Cycle structure of permutation g
        cycles = g.cyclic_form

        # Product over cycle lengths
        term = 1
        for cycle in cycles:
            cycle_len = len(cycle)
            term *= variables[cycle_len - 1]

        cycle_poly += term

    cycle_poly /= len(list(G.generate()))

    return cycle_poly
\end{lstlisting}


\subsubsection{Phase 5: Stereoisomer Enumeration (Months 5-6)}

Extend to 3D stereochemistry:


\begin{lstlisting}
def enumerate_stereoisomers(molecular_graph: nx.Graph) -> List:
    """
    For each structural isomer, enumerate stereoisomers.

    - Chiral centers: tetrahedral carbons with 4 different substituents
    - E/Z isomers: double bonds with different substituents
    - Conformers: rotations around single bonds (separate problem)
    """
    stereoisomers = []

    # Find chiral centers
    chiral_centers = find_chiral_carbons(molecular_graph)

    # 2^n stereoisomers for n chiral centers (R/S configurations)
    for config in itertools.product(['R', 'S'], repeat=len(chiral_centers)):
        G_stereo = molecular_graph.copy()

        for center, chirality in zip(chiral_centers, config):
            G_stereo.nodes[center]['chirality'] = chirality

        stereoisomers.append(G_stereo)

    # E/Z isomers (double bonds)
    double_bonds = [(u, v) for u, v in molecular_graph.edges
                    if molecular_graph[u][v]['bond_order'] == 2]

    for bond in double_bonds:
        # Check if E/Z isomerism possible
        if has_EZ_isomerism(molecular_graph, bond):
            # Generate both E and Z forms
            # ... (geometric isomer generation)
            pass

    return stereoisomers

def find_chiral_carbons(G: nx.Graph) -> List[int]:
    """
    Identify chiral centers (sp³ carbons with 4 different groups).
    """
    chiral = []

    for node in G.nodes:
        if G.nodes[node]['element'] != 'C':
            continue

        if G.degree(node) != 4:
            continue  # Must be tetrahedral

        # Check if 4 neighbors are distinct
        neighbors = list(G.neighbors(node))
        if all_distinct_substituents(G, neighbors):
            chiral.append(node)

    return chiral
\end{lstlisting}


\subsubsection{Phase 6: Export and Validation (Month 6)}

Generate output formats (SMILES, 3D structures):


\begin{lstlisting}
from rdkit import Chem
from rdkit.Chem import AllChem

def export_isomers(isomers: List[nx.Graph], output_dir: Path):
    """
    Export isomers as SMILES and 3D structures.
    """
    smiles_list = []

    for i, G in enumerate(isomers):
        # Convert to RDKit molecule
        mol = nx_graph_to_rdkit(G)

        # Generate SMILES
        smiles = Chem.MolToSmiles(mol)
        smiles_list.append(smiles)

        # Generate 3D coordinates (force field optimization)
        mol_3d = Chem.AddHs(mol)
        AllChem.EmbedMolecule(mol_3d)
        AllChem.UFFOptimizeMolecule(mol_3d)

        # Save as MOL file
        Chem.MolToMolFile(mol_3d, str(output_dir / f'isomer_{i:03d}.mol'))

    # Save all SMILES
    with open(output_dir / 'isomers.smi', 'w') as f:
        for smi in smiles_list:
            f.write(smi + '\n')

def nx_graph_to_rdkit(G: nx.Graph) -> Chem.Mol:
    """
    Convert NetworkX molecular graph to RDKit Mol object.
    """
    mol = Chem.RWMol()

    # Add atoms
    node_to_idx = {}
    for node in G.nodes:
        elem = G.nodes[node]['element']
        atom = Chem.Atom(elem)
        idx = mol.AddAtom(atom)
        node_to_idx[node] = idx

    # Add bonds
    for u, v in G.edges:
        bond_order = G[u][v].get('bond_order', 1)

        if bond_order == 1:
            bond_type = Chem.BondType.SINGLE
        elif bond_order == 2:
            bond_type = Chem.BondType.DOUBLE
        elif bond_order == 3:
            bond_type = Chem.BondType.TRIPLE

        mol.AddBond(node_to_idx[u], node_to_idx[v], bond_type)

    return mol.GetMol()
\end{lstlisting}


\bigskip\hrule\bigskip


\subsection{4. Example Starting Prompt}

\begin{lstlisting}
You are a computational chemist implementing isomer enumeration via graph theory. Generate ALL
structural isomers for molecular formulas using ONLY combinatorial algorithms—no databases.

OBJECTIVE: Enumerate all C₆H₁₂O isomers, verify completeness, export as SMILES.

PHASE 1 (Month 1): Brute force baseline
- Implement basic graph generation for C₄H₁₀
- Apply valence constraints (C:4, H:1, O:2)
- Remove duplicates using nauty canonical labeling
- Verify: find exactly 2 isomers (butane, isobutane)

PHASE 2 (Months 1-2): Canonical labeling
- Implement nauty algorithm for molecular graphs
- Color vertices by element type
- Test isomorphism detection on 100 random graph pairs

PHASE 3 (Months 2-4): Orderly generation
- Implement McKay's orderly algorithm
- Generate graphs in canonical order (avoids duplicates)
- Test on C₅H₁₂: should find 3 isomers

PHASE 4 (Months 4-5): Pólya enumeration
- Compute symmetry group for C₆H₁₂O
- Calculate cycle index polynomial
- Compare Pólya count to generated count (must match!)

PHASE 5 (Months 5-6): Stereoisomers
- Identify chiral centers in each structural isomer
- Enumerate R/S configurations
- Handle E/Z isomerism for double bonds

PHASE 6 (Month 6): Export and validation
- Convert all isomers to SMILES strings
- Generate 3D geometries using RDKit
- Cross-check against PubChem database (for validation only)

SUCCESS CRITERIA:
- MVR: C₄H₁₀ and C₅H₁₂ correctly enumerated
- Strong: C₆H₁₂O complete enumeration, all unique structures
- Publication: Systematic study up to C₈, comparison to Pólya counts

VERIFICATION:
- Generated count matches Pólya theoretical count
- All SMILES strings valid (parseable by RDKit)
- No duplicate structures (canonical checking)
- Cross-reference with PubChem (should find all known isomers)

Pure graph theory + combinatorics. No chemical databases until final validation.
All results certificate-based with completeness proofs.
\end{lstlisting}


\bigskip\hrule\bigskip


\subsection{5. Success Criteria}

\textbf{MVR} (2 months): C₄H₁₀, C₅H₁₂ correct, nauty working

\textbf{Strong} (4-5 months): C₆H₁₂O complete, Pólya counts verified

\textbf{Publication} (6 months): Systematic enumeration up to C₈, stereoisomers included



\bigskip\hrule\bigskip


\subsection{6. Verification Protocol}

\begin{itemize}
\item Compare generated counts to Pólya theoretical values

\item Cross-check SMILES against PubChem

\item Validate 3D geometries with quantum chemistry (DFT single-points)

\item Verify canonical labeling (no duplicates)



\bigskip\hrule\bigskip


\subsection{7. Resources & Milestones}

\end{itemize}

\textbf{References}:

\begin{itemize}
\item McKay (1998): "Isomorph-Free Exhaustive Generation"

\item Pólya (1937): "Kombinatorische Anzahlbestimmungen"

\item Read & Corneil (1977): "Graph Isomorphism Algorithms"


\end{itemize}

\textbf{Milestones}:

\begin{itemize}
\item Month 2: nauty integration complete

\item Month 4: Orderly generation working

\item Month 6: Full C₆H₁₂O enumeration + stereoisomers



\bigskip\hrule\bigskip


\subsection{8. Extensions}

\item \textbf{Reactivity Prediction}: Which isomers are most stable/reactive?

\item \textbf{Retrosynthesis}: Enumerate synthetic routes

\item \textbf{Protein Folding}: Graph enumeration for polymer conformations



\bigskip\hrule\bigskip

\end{itemize}

\textbf{End of PRD 17}


\end{document}
