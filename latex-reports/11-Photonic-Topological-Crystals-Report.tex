%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Photonic Topological Crystals from Symmetry
%% A Pure Thought Challenge: Designing Topological Photonic Structures
%% from First Principles Using Maxwell's Equations
%%
%% This document develops the complete theoretical and computational framework
%% for designing photonic crystals with nontrivial topology without relying
%% on experimental data or trial-and-error optimization.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[11pt,a4paper]{article}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% PACKAGES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{mathtools}
\usepackage{physics}
\usepackage{bm}
\usepackage{bbm}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage{tikz-cd}
\usetikzlibrary{arrows.meta,positioning,decorations.markings,calc,patterns,shapes.geometric}
\usepackage{tcolorbox}
\tcbuselibrary{skins,breakable,theorems}
\usepackage{listings}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{enumitem}
\usepackage{booktabs}
\usepackage{array}
\usepackage{multirow}
\usepackage{caption}
\usepackage{subcaption}

\geometry{margin=1in}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% CUSTOM COLORS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\definecolor{annotgray}{RGB}{245,245,245}
\definecolor{annotborder}{RGB}{180,180,180}
\definecolor{pursuitgreen}{RGB}{230,255,230}
\definecolor{pursuitborder}{RGB}{100,180,100}
\definecolor{warningred}{RGB}{255,235,235}
\definecolor{warningborder}{RGB}{200,100,100}
\definecolor{physicspurple}{RGB}{245,235,255}
\definecolor{physicsborder}{RGB}{140,100,180}
\definecolor{codegreen}{RGB}{0,128,0}
\definecolor{codegray}{RGB}{128,128,128}
\definecolor{codepurple}{RGB}{128,0,128}
\definecolor{backcolour}{RGB}{248,248,248}
\definecolor{photonblue}{RGB}{230,240,255}
\definecolor{photonborder}{RGB}{70,130,180}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% CUSTOM TCOLORBOX ENVIRONMENTS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newtcolorbox{annotation}[1][]{
    enhanced,
    breakable,
    colback=annotgray,
    colframe=annotborder,
    fonttitle=\bfseries,
    title={Annotation},
    #1
}

\newtcolorbox{pursuitbox}[1][]{
    enhanced,
    breakable,
    colback=pursuitgreen,
    colframe=pursuitborder,
    fonttitle=\bfseries,
    title={Pure Thought Pursuit},
    #1
}

\newtcolorbox{warningbox}[1][]{
    enhanced,
    breakable,
    colback=warningred,
    colframe=warningborder,
    fonttitle=\bfseries,
    title={Warning},
    #1
}

\newtcolorbox{physicsbox}[1][]{
    enhanced,
    breakable,
    colback=physicspurple,
    colframe=physicsborder,
    fonttitle=\bfseries,
    title={Physical Insight},
    #1
}

\newtcolorbox{photonbox}[1][]{
    enhanced,
    breakable,
    colback=photonblue,
    colframe=photonborder,
    fonttitle=\bfseries,
    title={Photonic Insight},
    #1
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% CODE LISTING STYLE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\lstdefinestyle{pythonstyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{codepurple}\bfseries,
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=4,
    language=Python,
    morekeywords={np,scipy,numpy,linalg,pi,exp,sin,cos,sqrt,array,zeros,ones,
                  linspace,meshgrid,eigvalsh,eigh,det,inv,kron,eye,diag,
                  arange,sum,abs,imag,real,conj,transpose,dot,matmul,fft,
                  fft2,ifft2,PhotonicCrystal,PhotonicCertificate}
}

\lstset{style=pythonstyle}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% THEOREM ENVIRONMENTS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}
\newtheorem{remark}[theorem]{Remark}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% CUSTOM COMMANDS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\BZ}{\mathrm{BZ}}
\newcommand{\Zn}[1]{\mathbb{Z}_{#1}}
\newcommand{\Ztwo}{\mathbb{Z}_2}
\newcommand{\CC}{\mathbb{C}}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\HH}{\mathcal{H}}
\newcommand{\PP}{\mathcal{P}}
\newcommand{\FF}{\mathcal{F}}
\newcommand{\id}{\mathbbm{1}}
\newcommand{\kvec}{\bm{k}}
\newcommand{\rvec}{\bm{r}}
\newcommand{\Rvec}{\bm{R}}
\newcommand{\Gvec}{\bm{G}}
\newcommand{\Evec}{\bm{E}}
\newcommand{\Hvec}{\bm{H}}
\newcommand{\Dvec}{\bm{D}}
\newcommand{\Bvec}{\bm{B}}
\newcommand{\Avec}{\bm{A}}
\newcommand{\eps}{\varepsilon}
\newcommand{\epsr}{\varepsilon(\rvec)}
\newcommand{\mur}{\mu(\rvec)}
\newcommand{\omegac}{\omega/c}
\newcommand{\chernnumber}{\mathcal{C}}
\newcommand{\BerryConn}{\mathcal{A}}
\newcommand{\BerryCurv}{\Omega}
\newcommand{\masterop}{\hat{\Theta}}
\newcommand{\proj}{\mathcal{P}}
\newcommand{\gyro}{\kappa}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% DOCUMENT INFO
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{\Huge\textbf{Photonic Topological Crystals from Symmetry}\\[1em]
       \Large A Pure Thought Challenge in Electromagnetic Topology}
\author{Pure Thought AI Challenges\\
        \texttt{pure-thought@challenges.ai}}
\date{\today}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% BEGIN DOCUMENT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

\begin{abstract}
This comprehensive report develops the complete theoretical and computational
framework for designing photonic crystals with nontrivial topology entirely
from first principles. Starting from Maxwell's equations for periodic dielectric
structures, we construct the plane wave expansion method for computing photonic
band structures, design gyromagnetic photonic Chern insulators by breaking
time-reversal symmetry, and compute topological invariants via Berry curvature
integration. We establish rigorous methods for calculating edge states using
ribbon geometry, certifying robustness against fabrication disorder, and
exporting fabrication-ready STL files for 3D printing. All results emerge
from pure mathematical analysis of electromagnetic theory combined with
group-theoretic symmetry principles---no experimental data or trial-and-error
optimization required. Complete Python implementations are provided for all
algorithms, enabling machine-verifiable certification of photonic topological
protection.
\end{abstract}

\tableofcontents
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction and Motivation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{pursuitbox}[title={The Pure Thought Challenge}]
Design photonic crystal structures exhibiting nontrivial topology using
\textbf{only} Maxwell's equations and symmetry principles---without any
experimental input, materials databases, or trial-and-error optimization.
All topological properties must be certified via machine-checkable proofs.
\end{pursuitbox}

\subsection{Scientific Context}

\textbf{Photonic crystals} are periodic arrangements of dielectric materials
that create photonic band gaps---frequency ranges where electromagnetic waves
cannot propagate. When combined with \textbf{topological band theory}, they
enable revolutionary optical devices with unprecedented robustness.

\begin{physicsbox}[title={Why Photonic Topology Matters}]
Topological photonic crystals enable:
\begin{enumerate}
    \item \textbf{Topologically protected edge states}: Light propagates along
          interfaces without backscattering, even around sharp corners
    \item \textbf{Robust waveguides}: Immune to disorder, defects, and
          fabrication imperfections
    \item \textbf{Unidirectional propagation}: Optical isolators and
          non-reciprocal devices
    \item \textbf{Topological lasers}: Single-mode operation enforced by
          topology rather than cavity design
\end{enumerate}
\end{physicsbox}

The key advantage of photonic systems for pure-thought challenges is
\textbf{complete theoretical predictability}:
\begin{itemize}
    \item Maxwell's equations are exact---no approximations needed
    \item Band structures computed from pure geometry and refractive indices
    \item No quantum many-body effects to complicate the analysis
    \item Fabrication-ready designs can be directly exported
\end{itemize}

\subsection{Historical Development}

The field of topological photonics emerged from the recognition that
electromagnetic waves in periodic structures exhibit band theory analogous
to electrons in crystals. Key milestones include:

\begin{enumerate}
    \item \textbf{Haldane \& Raghu (2008)}: Proposed photonic analogs of
          quantum Hall states using gyromagnetic materials
    \item \textbf{Wang et al. (2009)}: First experimental observation of
          unidirectional backscattering-immune electromagnetic edge states
    \item \textbf{Rechtsman et al. (2013)}: Floquet topological insulators
          in photonic lattices
    \item \textbf{Lu et al. (2014)}: Comprehensive review establishing
          ``Topological Photonics'' as a field
\end{enumerate}

\subsection{Scope of This Report}

We develop the complete framework for photonic topological crystal design:

\begin{enumerate}
    \item \textbf{Maxwell's equations}: Master equation formulation for
          periodic dielectrics
    \item \textbf{Plane wave expansion}: Numerical method for photonic
          band structure computation
    \item \textbf{Topological invariants}: Chern numbers and $\Ztwo$ indices
          for photonic bands
    \item \textbf{Gyromagnetic crystals}: Time-reversal breaking via
          magneto-optical materials
    \item \textbf{Edge state calculation}: Ribbon geometry and bulk-boundary
          correspondence
    \item \textbf{Robustness certification}: Disorder tolerance analysis
    \item \textbf{Fabrication export}: STL file generation for 3D printing
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Mathematical Foundations: Maxwell's Equations}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Maxwell's Equations in Matter}

In a source-free, linear, non-dispersive medium, Maxwell's equations take
the form:
\begin{align}
    \nabla \times \Evec &= -\frac{\partial \Bvec}{\partial t}
    \label{eq:faraday} \\
    \nabla \times \Hvec &= \frac{\partial \Dvec}{\partial t}
    \label{eq:ampere} \\
    \nabla \cdot \Dvec &= 0 \label{eq:gauss_d} \\
    \nabla \cdot \Bvec &= 0 \label{eq:gauss_b}
\end{align}

The constitutive relations for linear media are:
\begin{equation}
    \Dvec = \eps_0 \boldsymbol{\eps}(\rvec) \cdot \Evec, \quad
    \Bvec = \mu_0 \boldsymbol{\mu}(\rvec) \cdot \Hvec
    \label{eq:constitutive}
\end{equation}
where $\boldsymbol{\eps}(\rvec)$ and $\boldsymbol{\mu}(\rvec)$ are the
relative permittivity and permeability tensors.

\begin{definition}[Photonic Crystal]
A \textbf{photonic crystal} is a periodic arrangement of dielectric materials
where the permittivity satisfies:
\begin{equation}
    \eps(\rvec + \Rvec) = \eps(\rvec)
\end{equation}
for all Bravais lattice vectors $\Rvec = n_1 \bm{a}_1 + n_2 \bm{a}_2$
(in 2D) with $n_1, n_2 \in \ZZ$.
\end{definition}

\subsection{The Master Equation}

For time-harmonic fields $\Evec(\rvec, t) = \Evec(\rvec) e^{-i\omega t}$,
Maxwell's equations combine to give the \textbf{master equation}:

\begin{theorem}[Master Equation for Photonic Crystals]
The electromagnetic modes in a photonic crystal satisfy:
\begin{equation}
    \nabla \times \left( \frac{1}{\eps(\rvec)} \nabla \times \Hvec(\rvec) \right)
    = \left( \frac{\omega}{c} \right)^2 \Hvec(\rvec)
    \label{eq:master_H}
\end{equation}
or equivalently for the electric field:
\begin{equation}
    \frac{1}{\eps(\rvec)} \nabla \times \nabla \times \Evec(\rvec)
    = \left( \frac{\omega}{c} \right)^2 \Evec(\rvec)
    \label{eq:master_E}
\end{equation}
where we assume $\mu(\rvec) = 1$ (non-magnetic materials).
\end{theorem}

\begin{proof}
From Faraday's law \eqref{eq:faraday} with time-harmonic fields:
$\nabla \times \Evec = i\omega \mu_0 \Hvec$. Taking the curl and using
Amp\`{e}re's law \eqref{eq:ampere}: $\nabla \times \Hvec = -i\omega \eps_0 \eps(\rvec) \Evec$,
we obtain:
\begin{equation}
    \nabla \times \nabla \times \Evec = i\omega \mu_0 \nabla \times \Hvec
    = \omega^2 \mu_0 \eps_0 \eps(\rvec) \Evec = \frac{\omega^2}{c^2} \eps(\rvec) \Evec
\end{equation}
Rearranging gives \eqref{eq:master_E}. The $\Hvec$-field version follows similarly.
\end{proof}

\begin{annotation}[title={Why Use the $\Hvec$-field Formulation?}]
The master equation \eqref{eq:master_H} defines a \textbf{Hermitian} eigenvalue
problem when $\eps(\rvec) > 0$. The operator
$\masterop = \nabla \times \eps^{-1}(\rvec) \nabla \times$ is Hermitian under
the inner product $\langle \Hvec_1, \Hvec_2 \rangle = \int \Hvec_1^* \cdot \Hvec_2 \, d^3r$,
guaranteeing real eigenvalues $\omega^2 \geq 0$.
\end{annotation}

\subsection{Bloch's Theorem for Photonic Crystals}

\begin{theorem}[Bloch's Theorem]
For a photonic crystal with periodic $\eps(\rvec)$, the electromagnetic
eigenmodes can be written as Bloch waves:
\begin{equation}
    \Hvec_{n\kvec}(\rvec) = e^{i\kvec \cdot \rvec} \bm{u}_{n\kvec}(\rvec)
    \label{eq:bloch_H}
\end{equation}
where $\bm{u}_{n\kvec}(\rvec + \Rvec) = \bm{u}_{n\kvec}(\rvec)$ has the
periodicity of the lattice, $n$ is the band index, and $\kvec$ is the
Bloch wavevector in the first Brillouin zone.
\end{theorem}

Substituting the Bloch form into the master equation yields an eigenvalue
problem for the periodic part:
\begin{equation}
    \masterop_\kvec \bm{u}_{n\kvec} = \left( \frac{\omega_n(\kvec)}{c} \right)^2 \bm{u}_{n\kvec}
    \label{eq:master_bloch}
\end{equation}
where the \textbf{Bloch master operator} is:
\begin{equation}
    \masterop_\kvec = (\nabla + i\kvec) \times \frac{1}{\eps(\rvec)}
    (\nabla + i\kvec) \times
    \label{eq:master_operator}
\end{equation}

\begin{definition}[Photonic Band Structure]
The \textbf{photonic band structure} $\omega_n(\kvec)$ consists of the
eigenfrequencies of $\masterop_\kvec$ as functions of $\kvec$ in the
Brillouin zone. Regions where no propagating modes exist are called
\textbf{photonic band gaps}.
\end{definition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Plane Wave Expansion Method}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Fourier Expansion of Permittivity}

The periodic permittivity admits a Fourier series:
\begin{equation}
    \eps(\rvec) = \sum_{\Gvec} \eps_\Gvec e^{i\Gvec \cdot \rvec}
    \label{eq:eps_fourier}
\end{equation}
where $\Gvec$ are reciprocal lattice vectors and the Fourier coefficients are:
\begin{equation}
    \eps_\Gvec = \frac{1}{V_{\text{cell}}} \int_{\text{cell}} \eps(\rvec)
    e^{-i\Gvec \cdot \rvec} d^2r
    \label{eq:eps_fourier_coeff}
\end{equation}

\begin{definition}[Reciprocal Lattice]
For a 2D Bravais lattice with primitive vectors $\bm{a}_1, \bm{a}_2$, the
reciprocal lattice vectors are:
\begin{equation}
    \bm{b}_1 = 2\pi \frac{\bm{a}_2 \times \hat{z}}{|\bm{a}_1 \times \bm{a}_2|}, \quad
    \bm{b}_2 = 2\pi \frac{\hat{z} \times \bm{a}_1}{|\bm{a}_1 \times \bm{a}_2|}
\end{equation}
satisfying $\bm{a}_i \cdot \bm{b}_j = 2\pi \delta_{ij}$.
\end{definition}

Similarly, we expand the Bloch periodic functions:
\begin{equation}
    \bm{u}_{n\kvec}(\rvec) = \sum_{\Gvec} \bm{c}_{n\kvec}(\Gvec) e^{i\Gvec \cdot \rvec}
    \label{eq:u_fourier}
\end{equation}

\subsection{Matrix Eigenvalue Problem}

Substituting the Fourier expansions into the master equation yields a
matrix eigenvalue problem. For 2D photonic crystals with TE polarization
($\Evec$ perpendicular to the plane), we obtain:

\begin{theorem}[Plane Wave Eigenvalue Problem (TE Modes)]
The photonic band structure is determined by:
\begin{equation}
    \sum_{\Gvec'} M_{\Gvec,\Gvec'}(\kvec) c(\Gvec') =
    \left( \frac{\omega}{c} \right)^2 c(\Gvec)
    \label{eq:pwe_eigenvalue}
\end{equation}
where the matrix elements are:
\begin{equation}
    M_{\Gvec,\Gvec'}(\kvec) = |\kvec + \Gvec|^2 \delta_{\Gvec,\Gvec'}
    - (\kvec + \Gvec) \cdot (\kvec + \Gvec') \, \eta_{\Gvec - \Gvec'}
    \label{eq:pwe_matrix}
\end{equation}
with $\eta_\Gvec = (\eps^{-1})_\Gvec$ being the Fourier coefficients of the
inverse permittivity.
\end{theorem}

\begin{warningbox}[title={Inverse Rule vs. Direct Rule}]
A critical numerical issue: for high dielectric contrast, one must use the
\textbf{inverse rule}---compute Fourier coefficients of $\eps^{-1}(\rvec)$
rather than inverting the matrix of $\eps_\Gvec$ coefficients. The latter
leads to poor convergence. Specifically:
\begin{equation}
    \eta_\Gvec = \frac{1}{V_{\text{cell}}} \int_{\text{cell}}
    \frac{1}{\eps(\rvec)} e^{-i\Gvec \cdot \rvec} d^2r
    \quad \text{(correct)}
\end{equation}
\end{warningbox}

\subsection{Implementation of Plane Wave Expansion}

\begin{lstlisting}[caption={Reciprocal lattice vector generation}]
import numpy as np
from scipy.linalg import eigh
from typing import List, Tuple, Callable

def generate_reciprocal_lattice(a1: np.ndarray, a2: np.ndarray,
                                 N_max: int = 5) -> List[np.ndarray]:
    """
    Generate reciprocal lattice vectors G for plane wave expansion.

    Parameters:
        a1, a2: Primitive lattice vectors
        N_max: Maximum index |n1|, |n2| <= N_max

    Returns:
        List of G vectors: G = n1*b1 + n2*b2
    """
    # Compute reciprocal basis (2D)
    cross = a1[0]*a2[1] - a1[1]*a2[0]
    b1 = 2*np.pi * np.array([a2[1], -a2[0]]) / cross
    b2 = 2*np.pi * np.array([-a1[1], a1[0]]) / cross

    G_vectors = []
    for n1 in range(-N_max, N_max + 1):
        for n2 in range(-N_max, N_max + 1):
            G_vectors.append(n1*b1 + n2*b2)

    return G_vectors, b1, b2

def compute_epsilon_fourier(eps_func: Callable[[np.ndarray], float],
                            a1: np.ndarray, a2: np.ndarray,
                            G_vectors: List[np.ndarray],
                            N_grid: int = 128) -> dict:
    """
    Compute Fourier coefficients of 1/epsilon using FFT.

    Uses the inverse rule for proper convergence.
    """
    # Real-space grid over unit cell
    u_vals = np.linspace(0, 1, N_grid, endpoint=False)
    v_vals = np.linspace(0, 1, N_grid, endpoint=False)

    # Inverse permittivity on grid
    inv_eps_grid = np.zeros((N_grid, N_grid), dtype=complex)

    for i, u in enumerate(u_vals):
        for j, v in enumerate(v_vals):
            r = u * a1 + v * a2
            inv_eps_grid[i, j] = 1.0 / eps_func(r)

    # 2D FFT
    inv_eps_fft = np.fft.fft2(inv_eps_grid) / (N_grid**2)

    # Extract coefficients for each G vector
    eta_G = {}
    cross = a1[0]*a2[1] - a1[1]*a2[0]
    b1 = 2*np.pi * np.array([a2[1], -a2[0]]) / cross
    b2 = 2*np.pi * np.array([-a1[1], a1[0]]) / cross

    for G in G_vectors:
        # Find (n1, n2) from G = n1*b1 + n2*b2
        # Solve linear system
        B = np.array([b1, b2]).T
        n = np.linalg.solve(B, G)
        n1, n2 = int(round(n[0])), int(round(n[1]))

        # Map to FFT indices (with wrapping)
        i1 = n1 % N_grid
        i2 = n2 % N_grid

        eta_G[tuple(G.round(10))] = inv_eps_fft[i1, i2]

    return eta_G
\end{lstlisting}

\begin{lstlisting}[caption={Master operator matrix construction}]
def build_master_matrix_TE(k: np.ndarray, G_vectors: List[np.ndarray],
                           eta_G: dict) -> np.ndarray:
    """
    Build the master operator matrix for TE polarization.

    M_{G,G'} = |k+G|^2 delta_{G,G'} - (k+G).(k+G') eta_{G-G'}

    For TE modes: E_z only, H in-plane
    """
    N_G = len(G_vectors)
    M = np.zeros((N_G, N_G), dtype=complex)

    for i, G in enumerate(G_vectors):
        k_plus_G = k + G
        for j, Gp in enumerate(G_vectors):
            k_plus_Gp = k + Gp

            # Get eta_{G - G'}
            G_diff = tuple((G - Gp).round(10))
            eta = eta_G.get(G_diff, 0.0)

            if i == j:
                # Diagonal: |k+G|^2 * eta_0
                M[i, j] = np.dot(k_plus_G, k_plus_G) * eta_G[tuple(np.zeros(2))]
            else:
                # Off-diagonal
                M[i, j] = -np.dot(k_plus_G, k_plus_Gp) * eta

    return M

def compute_photonic_bands(eps_func: Callable, a1: np.ndarray,
                           a2: np.ndarray, k_path: List[np.ndarray],
                           N_bands: int = 10, N_G: int = 5) -> np.ndarray:
    """
    Compute photonic band structure along k-path.

    Returns: bands[i_k, n] = omega_n(k_i) in units of c/a
    """
    G_vectors, b1, b2 = generate_reciprocal_lattice(a1, a2, N_G)
    eta_G = compute_epsilon_fourier(eps_func, a1, a2, G_vectors)

    bands = np.zeros((len(k_path), N_bands))

    for i_k, k in enumerate(k_path):
        M = build_master_matrix_TE(k, G_vectors, eta_G)

        # Solve eigenvalue problem: M u = (omega/c)^2 u
        eigenvalues = np.linalg.eigvalsh(M)

        # omega = c * sqrt(lambda), take positive real part
        eigenvalues = np.sort(np.real(eigenvalues))
        eigenvalues = eigenvalues[eigenvalues > 1e-10]  # Remove zero modes

        frequencies = np.sqrt(eigenvalues[:N_bands])
        bands[i_k, :len(frequencies)] = frequencies

    return bands
\end{lstlisting}

\subsection{High-Symmetry Path in the Brillouin Zone}

For a hexagonal lattice (relevant for honeycomb photonic crystals), the
high-symmetry points are:
\begin{align}
    \Gamma &= (0, 0) \\
    M &= \frac{1}{2}\bm{b}_1 \\
    K &= \frac{1}{3}(\bm{b}_1 + \bm{b}_2)
\end{align}

\begin{lstlisting}[caption={High-symmetry path generation}]
def generate_k_path_hexagonal(b1: np.ndarray, b2: np.ndarray,
                               N_points: int = 100) -> Tuple[np.ndarray, list]:
    """
    Generate k-path: Gamma -> M -> K -> Gamma for hexagonal BZ.
    """
    Gamma = np.array([0.0, 0.0])
    M = b1 / 2
    K = (b1 + b2) / 3

    # Path segments
    GM = np.linspace(Gamma, M, N_points//3, endpoint=False)
    MK = np.linspace(M, K, N_points//3, endpoint=False)
    KG = np.linspace(K, Gamma, N_points//3 + 1)

    k_path = np.vstack([GM, MK, KG])
    labels = [(0, r'$\Gamma$'), (N_points//3, 'M'),
              (2*N_points//3, 'K'), (N_points, r'$\Gamma$')]

    return k_path, labels

def identify_band_gap(bands: np.ndarray) -> Tuple[int, float, float, float]:
    """
    Find the largest complete photonic band gap.

    Returns: (gap_index, omega_lower, omega_upper, gap_ratio)
    where gap_ratio = (omega_upper - omega_lower) / omega_midgap
    """
    N_k, N_bands = bands.shape

    best_gap = None
    best_ratio = 0

    for n in range(N_bands - 1):
        # Upper edge of band n
        omega_upper_n = np.max(bands[:, n])
        # Lower edge of band n+1
        omega_lower_np1 = np.min(bands[:, n + 1])

        if omega_lower_np1 > omega_upper_n:
            gap_size = omega_lower_np1 - omega_upper_n
            midgap = (omega_lower_np1 + omega_upper_n) / 2
            ratio = gap_size / midgap

            if ratio > best_ratio:
                best_ratio = ratio
                best_gap = (n, omega_upper_n, omega_lower_np1, ratio)

    return best_gap if best_gap else (None, 0, 0, 0)
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Topological Photonic Crystals}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Breaking Time-Reversal Symmetry}

To achieve a nonzero Chern number, we must break time-reversal symmetry.
In photonics, this is accomplished using \textbf{gyromagnetic materials}
(magneto-optical materials in an external magnetic field).

\begin{definition}[Gyromagnetic Permittivity Tensor]
A gyromagnetic material has an antisymmetric permittivity tensor:
\begin{equation}
    \boldsymbol{\eps} = \begin{pmatrix}
        \eps_\perp & i\gyro & 0 \\
        -i\gyro & \eps_\perp & 0 \\
        0 & 0 & \eps_\parallel
    \end{pmatrix}
    \label{eq:gyromagnetic_tensor}
\end{equation}
where $\gyro$ is the gyromagnetic coupling proportional to the applied
magnetic field $B_z$.
\end{definition}

\begin{physicsbox}[title={Physical Origin of Gyromagnetic Response}]
In ferrites (e.g., YIG - Yttrium Iron Garnet), electron spin precession
in a magnetic field creates a frequency-dependent, asymmetric response.
The off-diagonal elements $\pm i\gyro$ cause different responses to
left- and right-circularly polarized light, breaking time-reversal symmetry
$\Evec(t) \to \Evec(-t)$, $\Bvec(t) \to -\Bvec(-t)$.
\end{physicsbox}

\subsection{Photonic Chern Insulator Design}

Following Haldane and Raghu's proposal, we design a photonic Chern insulator
on a honeycomb lattice:

\begin{lstlisting}[caption={Gyromagnetic honeycomb photonic crystal}]
class PhotonicCrystal:
    """Photonic crystal structure definition."""

    def __init__(self, dimension: int, lattice_vectors: List[np.ndarray],
                 permittivity_func: Callable, permeability_func: Callable = None):
        self.dimension = dimension
        self.lattice_vectors = lattice_vectors
        self.permittivity_func = permittivity_func
        self.permeability_func = permeability_func or (lambda r: 1.0)

def create_gyromagnetic_honeycomb(rod_radius: float = 0.2,
                                   eps_rod: float = 12.0,
                                   gyro_strength: float = 0.1) -> PhotonicCrystal:
    """
    Create honeycomb photonic crystal with gyromagnetic rods.

    Two sublattices with opposite gyromagnetic response create
    a photonic analog of the Haldane model.
    """
    # Honeycomb lattice vectors
    a = 1.0  # Lattice constant
    a1 = a * np.array([1.0, 0.0])
    a2 = a * np.array([0.5, np.sqrt(3)/2])

    # Sublattice positions within unit cell
    # A site at origin, B site at (a1 + a2)/3
    delta_B = (a1 + a2) / 3

    def eps_honeycomb(r: np.ndarray) -> complex:
        """
        Permittivity function with gyromagnetic response.

        Returns effective scalar for 2D simulation.
        The imaginary part encodes gyromagnetic coupling.
        """
        # Reduce r to unit cell
        # (simplified - assumes r is already in cell)

        # Distance to A sublattice (origin)
        dist_A = np.linalg.norm(r % a1 % a2)  # Simplified

        # For proper implementation, check all periodic images
        for n1 in [-1, 0, 1]:
            for n2 in [-1, 0, 1]:
                R = n1 * a1 + n2 * a2

                # Check A site
                r_A = r - R
                if np.linalg.norm(r_A) < rod_radius:
                    # A sublattice: positive gyromagnetic
                    return eps_rod * (1 + 1j * gyro_strength)

                # Check B site
                r_B = r - R - delta_B
                if np.linalg.norm(r_B) < rod_radius:
                    # B sublattice: negative gyromagnetic
                    return eps_rod * (1 - 1j * gyro_strength)

        # Background (air)
        return 1.0

    return PhotonicCrystal(
        dimension=2,
        lattice_vectors=[a1, a2],
        permittivity_func=eps_honeycomb
    )
\end{lstlisting}

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[scale=2.5]
    % Honeycomb lattice vectors
    \coordinate (a1) at (1, 0);
    \coordinate (a2) at (0.5, 0.866);

    % Draw unit cell
    \draw[thick, gray, dashed] (0,0) -- (a1) -- ($(a1)+(a2)$) -- (a2) -- cycle;

    % Draw multiple unit cells
    \foreach \n in {-1,0,1} {
        \foreach \m in {-1,0,1} {
            % A sublattice (red, positive gyro)
            \filldraw[fill=red!60, draw=red!80!black]
                ($\n*(a1)+\m*(a2)$) circle (0.12);
            % B sublattice (blue, negative gyro)
            \filldraw[fill=blue!60, draw=blue!80!black]
                ($\n*(a1)+\m*(a2)+(0.5,0.289)$) circle (0.12);
        }
    }

    % Labels
    \node[below left] at (0,0) {A};
    \node[above right] at (0.5, 0.289) {B};
    \node[below] at (0.5, -0.3) {$\bm{a}_1$};
    \node[left] at (-0.1, 0.4) {$\bm{a}_2$};

    % Legend
    \node[right] at (1.8, 0.6) {\small $+i\kappa$};
    \node[right] at (1.8, 0.3) {\small $-i\kappa$};
    \filldraw[fill=red!60] (1.7, 0.6) circle (0.08);
    \filldraw[fill=blue!60] (1.7, 0.3) circle (0.08);
\end{tikzpicture}
\caption{Honeycomb lattice with gyromagnetic rods. Red (A sublattice) and blue
(B sublattice) rods have opposite gyromagnetic response $\pm i\kappa$, breaking
time-reversal symmetry and inducing nonzero Chern number.}
\label{fig:honeycomb_gyro}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Berry Curvature and Chern Number}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Berry Phase for Photonic Bands}

The topological properties of photonic bands are encoded in the Berry phase
geometry, identical in structure to electronic systems.

\begin{definition}[Photonic Berry Connection]
For a photonic band with Bloch modes $\bm{u}_{n\kvec}$, the Berry connection is:
\begin{equation}
    \BerryConn_\mu^{(n)}(\kvec) = i \langle \bm{u}_{n\kvec} | \partial_{k_\mu} | \bm{u}_{n\kvec} \rangle
    \label{eq:berry_connection_photonic}
\end{equation}
where the inner product is:
\begin{equation}
    \langle \bm{u} | \bm{v} \rangle = \int_{\text{cell}} \bm{u}^*(\rvec) \cdot \bm{v}(\rvec) \, d^2r
\end{equation}
\end{definition}

\begin{definition}[Photonic Berry Curvature]
The Berry curvature is the curl of the connection:
\begin{equation}
    \BerryCurv^{(n)}(\kvec) = \partial_{k_x} \BerryConn_y^{(n)} - \partial_{k_y} \BerryConn_x^{(n)}
    = i \langle \partial_{k_x} u_n | \partial_{k_y} u_n \rangle - (x \leftrightarrow y)
    \label{eq:berry_curvature_photonic}
\end{equation}
\end{definition}

\begin{definition}[Photonic Chern Number]
The Chern number of photonic band $n$ is:
\begin{equation}
    \chernnumber_n = \frac{1}{2\pi} \int_{\BZ} \BerryCurv^{(n)}(\kvec) \, d^2k \in \ZZ
    \label{eq:chern_number_photonic}
\end{equation}
\end{definition}

\subsection{Fukui-Hatsugai-Suzuki Lattice Gauge Method}

For numerical computation, we discretize the Brillouin zone and use the
gauge-invariant Fukui-Hatsugai-Suzuki method:

\begin{theorem}[FHS Method for Chern Number]
Discretize the BZ into a grid $\kvec_{ij}$ with plaquettes. For each plaquette,
define the link variables:
\begin{equation}
    U_\mu(\kvec) = \frac{\langle \bm{u}_\kvec | \bm{u}_{\kvec + \hat{\mu}} \rangle}
    {|\langle \bm{u}_\kvec | \bm{u}_{\kvec + \hat{\mu}} \rangle|}
    \label{eq:link_variable}
\end{equation}
The lattice field strength is:
\begin{equation}
    F_{12}(\kvec) = \ln \left[ U_1(\kvec) U_2(\kvec + \hat{1}) U_1^*(\kvec + \hat{2}) U_2^*(\kvec) \right]
    \label{eq:lattice_field_strength}
\end{equation}
and the Chern number is:
\begin{equation}
    \chernnumber = \frac{1}{2\pi i} \sum_{\text{plaquettes}} F_{12}(\kvec)
    \label{eq:chern_fhs}
\end{equation}
\end{theorem}

\begin{lstlisting}[caption={Fukui-Hatsugai-Suzuki Chern number computation}]
def compute_berry_curvature_fhs(eigenvectors: np.ndarray,
                                 band_index: int,
                                 dk: float) -> np.ndarray:
    """
    Compute Berry curvature using FHS lattice gauge method.

    eigenvectors[i, j, :, n] = eigenvector for band n at k-point (i,j)
    """
    N_kx, N_ky = eigenvectors.shape[:2]
    F = np.zeros((N_kx, N_ky))

    for i in range(N_kx):
        for j in range(N_ky):
            # Get eigenvectors at corners of plaquette
            u00 = eigenvectors[i, j, :, band_index]
            u10 = eigenvectors[(i+1) % N_kx, j, :, band_index]
            u01 = eigenvectors[i, (j+1) % N_ky, :, band_index]
            u11 = eigenvectors[(i+1) % N_kx, (j+1) % N_ky, :, band_index]

            # Link variables (normalized overlaps)
            U1_00 = np.vdot(u00, u10)
            U1_00 /= np.abs(U1_00)

            U2_10 = np.vdot(u10, u11)
            U2_10 /= np.abs(U2_10)

            U1_01 = np.vdot(u01, u11)
            U1_01 /= np.abs(U1_01)

            U2_00 = np.vdot(u00, u01)
            U2_00 /= np.abs(U2_00)

            # Wilson loop around plaquette
            W = U1_00 * U2_10 * np.conj(U1_01) * np.conj(U2_00)

            # Lattice field strength
            F[i, j] = np.imag(np.log(W))

    return F / dk**2

def compute_chern_number(eps_func: Callable, a1: np.ndarray,
                         a2: np.ndarray, band_indices: List[int],
                         N_k: int = 50, N_G: int = 5) -> int:
    """
    Compute Chern number for specified bands.

    Returns integer Chern number.
    """
    G_vectors, b1, b2 = generate_reciprocal_lattice(a1, a2, N_G)
    eta_G = compute_epsilon_fourier(eps_func, a1, a2, G_vectors)

    # Discretize BZ
    kx_frac = np.linspace(0, 1, N_k, endpoint=False)
    ky_frac = np.linspace(0, 1, N_k, endpoint=False)
    dk = 1.0 / N_k

    # Store eigenvectors
    N_bands = len(G_vectors)
    eigenvectors = np.zeros((N_k, N_k, N_bands, N_bands), dtype=complex)

    for i, kx in enumerate(kx_frac):
        for j, ky in enumerate(ky_frac):
            k = kx * b1 + ky * b2
            M = build_master_matrix_TE(k, G_vectors, eta_G)

            # Get eigenvectors
            evals, evecs = np.linalg.eigh(M)
            eigenvectors[i, j] = evecs

    # Sum Berry curvature over occupied bands
    total_chern = 0.0

    for band in band_indices:
        F = compute_berry_curvature_fhs(eigenvectors, band, dk)
        chern_band = np.sum(F) / (2 * np.pi)
        total_chern += chern_band

    return int(np.round(total_chern))
\end{lstlisting}

\subsection{Chern Number from Band Structure Symmetry}

For the gyromagnetic honeycomb model, the Chern number can be predicted
from symmetry analysis:

\begin{theorem}[Chern Number of Gyromagnetic Honeycomb]
\label{thm:chern_honeycomb}
For a honeycomb photonic crystal with gyromagnetic coupling $\kappa$,
the Chern number of the lowest band is:
\begin{equation}
    \chernnumber = \text{sgn}(\kappa) \cdot \text{sgn}(\Delta M)
\end{equation}
where $\Delta M$ is the mass term (band gap) at the Dirac points K and K'.
\end{theorem}

\begin{physicsbox}[title={Analogy with Electronic Haldane Model}]
The photonic honeycomb crystal with gyromagnetic rods is the direct
electromagnetic analog of Haldane's electronic model on graphene.
The gyromagnetic coupling $\kappa$ plays the role of the complex
next-nearest-neighbor hopping phase $\phi$, and the A/B sublattice
asymmetry corresponds to the staggered potential $M$.
\end{physicsbox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Edge State Calculation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Bulk-Boundary Correspondence}

\begin{theorem}[Bulk-Boundary Correspondence for Photonic Crystals]
A photonic crystal with Chern number $\chernnumber \neq 0$ supports exactly
$|\chernnumber|$ chiral edge modes at any interface with a trivial
($\chernnumber = 0$) material or vacuum. The edge modes propagate
unidirectionally with group velocity sign determined by $\text{sgn}(\chernnumber)$.
\end{theorem}

\subsection{Ribbon Geometry}

To compute edge states, we use a \textbf{ribbon geometry}: the crystal is
periodic in $x$ but finite in $y$.

\begin{lstlisting}[caption={Ribbon geometry for edge state calculation}]
def create_ribbon_hamiltonian(eps_func: Callable, a1: np.ndarray,
                               a2: np.ndarray, N_cells_y: int,
                               k_x: float, N_G_x: int = 5) -> np.ndarray:
    """
    Construct Hamiltonian for ribbon geometry.

    Periodic in x, finite in y with N_cells_y unit cells.
    k_x is the conserved momentum along x.
    """
    # For ribbon: expand in plane waves along x, real space along y
    G_x_list = [n * 2 * np.pi / np.linalg.norm(a1)
                for n in range(-N_G_x, N_G_x + 1)]
    N_Gx = len(G_x_list)

    # Total dimension: N_Gx * N_cells_y
    dim = N_Gx * N_cells_y
    H_ribbon = np.zeros((dim, dim), dtype=complex)

    # Build Hamiltonian block by block
    for n_y in range(N_cells_y):
        for m_y in range(N_cells_y):
            for i_G, G_x in enumerate(G_x_list):
                for j_G, G_x_p in enumerate(G_x_list):
                    # Matrix element from epsilon coupling
                    # H_{(n_y,G_x), (m_y,G_x')}

                    idx_i = n_y * N_Gx + i_G
                    idx_j = m_y * N_Gx + j_G

                    # Compute coupling integral
                    coupling = compute_ribbon_coupling(
                        eps_func, a1, a2, n_y, m_y,
                        k_x + G_x, k_x + G_x_p
                    )

                    H_ribbon[idx_i, idx_j] = coupling

    return H_ribbon

def compute_edge_spectrum(crystal: PhotonicCrystal, N_cells_y: int = 30,
                          N_kx: int = 100) -> Tuple[np.ndarray, np.ndarray]:
    """
    Compute edge state spectrum omega(k_x) for ribbon geometry.

    Returns: k_x_values, omega_spectrum
    """
    a1, a2 = crystal.lattice_vectors

    # k_x along the ribbon direction
    k_x_values = np.linspace(-np.pi/np.linalg.norm(a1),
                              np.pi/np.linalg.norm(a1), N_kx)

    spectrum = []

    for k_x in k_x_values:
        H = create_ribbon_hamiltonian(
            crystal.permittivity_func, a1, a2, N_cells_y, k_x
        )

        # Eigenvalues are (omega/c)^2
        evals = np.linalg.eigvalsh(H)
        omega = np.sqrt(np.maximum(evals, 0))

        spectrum.append(np.sort(omega))

    return k_x_values, np.array(spectrum)

def identify_edge_states(k_x_values: np.ndarray, spectrum: np.ndarray,
                         gap_lower: float, gap_upper: float,
                         eigenvectors: np.ndarray = None) -> dict:
    """
    Identify edge states within the bulk gap.

    Returns dictionary with edge state properties.
    """
    edge_states = {
        'k_x': [],
        'omega': [],
        'chirality': [],
        'localization': []
    }

    for i_k, k_x in enumerate(k_x_values):
        for i_band, omega in enumerate(spectrum[i_k]):
            if gap_lower < omega < gap_upper:
                edge_states['k_x'].append(k_x)
                edge_states['omega'].append(omega)

                # Determine chirality from group velocity
                if i_k > 0 and i_k < len(k_x_values) - 1:
                    # Find corresponding state at neighboring k
                    # (simplified - proper tracking needed)
                    d_omega = spectrum[i_k+1, i_band] - spectrum[i_k-1, i_band]
                    d_k = k_x_values[i_k+1] - k_x_values[i_k-1]
                    v_g = d_omega / d_k
                    edge_states['chirality'].append(np.sign(v_g))

    return edge_states
\end{lstlisting}

\subsection{Edge State Visualization}

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[scale=1.2]
    % Axes
    \draw[->] (-3, 0) -- (3, 0) node[right] {$k_x$};
    \draw[->] (0, 0) -- (0, 4.5) node[above] {$\omega$};

    % Bulk bands (shaded)
    \fill[blue!20] (-2.5, 0.3) -- (2.5, 0.3) -- (2.5, 1.5) -- (-2.5, 1.5) -- cycle;
    \fill[blue!20] (-2.5, 2.5) -- (2.5, 2.5) -- (2.5, 4) -- (-2.5, 4) -- cycle;

    % Gap region
    \fill[yellow!20] (-2.5, 1.5) -- (2.5, 1.5) -- (2.5, 2.5) -- (-2.5, 2.5) -- cycle;

    % Edge state (chiral, crossing the gap)
    \draw[thick, red] (-2.5, 1.6) .. controls (-1, 1.8) and (1, 2.2) .. (2.5, 2.4);

    % Labels
    \node at (0, 0.9) {Bulk band 1};
    \node at (0, 3.25) {Bulk band 2};
    \node[red] at (1.8, 1.8) {Edge state};
    \node at (-2, 2) {Gap};

    % High symmetry points
    \node[below] at (-2.1, 0) {$-\pi/a$};
    \node[below] at (2.1, 0) {$\pi/a$};
    \node[below] at (0, 0) {$0$};

    % Arrow showing chirality
    \draw[->, thick, red] (0.5, 2) -- (1.5, 2.15);
    \node[red, above] at (1, 2.1) {$v_g > 0$};
\end{tikzpicture}
\caption{Schematic of photonic edge state spectrum in ribbon geometry.
The chiral edge state (red) crosses the bulk band gap with definite
group velocity sign, demonstrating unidirectional propagation.}
\label{fig:edge_spectrum}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{$\Ztwo$ Topological Photonics}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Time-Reversal Invariant Systems}

When time-reversal symmetry is preserved, the Chern number vanishes but
a $\Ztwo$ topological invariant can be nontrivial.

\begin{definition}[Photonic Time-Reversal Symmetry]
For photonic systems, time-reversal acts as:
\begin{equation}
    \mathcal{T}: \Evec(\rvec, t) \to \Evec(\rvec, -t), \quad
    \Hvec(\rvec, t) \to -\Hvec(\rvec, -t)
\end{equation}
In frequency domain: $\mathcal{T}: \Evec_\kvec \to \Evec_{-\kvec}^*$.
\end{definition}

\begin{definition}[$\Ztwo$ Invariant for Photonic Crystals]
For time-reversal invariant photonic crystals with inversion symmetry,
the $\Ztwo$ invariant is computed from parity eigenvalues at the four
time-reversal invariant momenta (TRIM) $\Gamma_i$:
\begin{equation}
    (-1)^\nu = \prod_{i=1}^{4} \prod_{n \in \text{occ}} \xi_n(\Gamma_i)
    \label{eq:z2_parity}
\end{equation}
where $\xi_n(\Gamma_i) = \pm 1$ are parity eigenvalues.
\end{definition}

\subsection{Bianisotropic Metamaterials}

$\Ztwo$ topological photonics can be realized using bianisotropic
metamaterials that couple electric and magnetic fields:

\begin{equation}
    \begin{pmatrix} \Dvec \\ \Bvec \end{pmatrix} =
    \begin{pmatrix} \boldsymbol{\eps} & \boldsymbol{\chi} \\
                    \boldsymbol{\chi}^T & \boldsymbol{\mu} \end{pmatrix}
    \begin{pmatrix} \Evec \\ \Hvec \end{pmatrix}
    \label{eq:bianisotropic}
\end{equation}

\begin{lstlisting}[caption={$\Ztwo$ invariant computation}]
def compute_z2_invariant(crystal: PhotonicCrystal,
                         occupied_bands: List[int]) -> int:
    """
    Compute Z2 invariant for time-reversal symmetric photonic crystal.

    Uses parity eigenvalues at TRIM points.
    """
    a1, a2 = crystal.lattice_vectors
    _, b1, b2 = generate_reciprocal_lattice(a1, a2, 1)

    # Time-reversal invariant momenta (TRIM)
    TRIM = [
        np.array([0, 0]),           # Gamma
        b1 / 2,                     # M1
        b2 / 2,                     # M2
        (b1 + b2) / 2               # M3
    ]

    product = 1

    for Gamma_i in TRIM:
        # Compute eigenstates at TRIM
        H_k = build_photonic_hamiltonian(crystal, Gamma_i)
        evals, evecs = np.linalg.eigh(H_k)

        # Inversion operator (for crystal with inversion center at origin)
        P = build_inversion_operator(crystal)

        # Parity eigenvalues of occupied bands
        for n in occupied_bands:
            psi_n = evecs[:, n]

            # Parity eigenvalue: <psi|P|psi>
            xi_n = np.real(np.vdot(psi_n, P @ psi_n))
            xi_n = np.sign(xi_n)  # Should be +/- 1

            product *= xi_n

    # nu = 0 if product = +1, nu = 1 if product = -1
    nu = 0 if product > 0 else 1

    return nu
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Robustness Certification}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Disorder Model}

To certify topological protection, we test robustness against disorder:

\begin{definition}[Permittivity Disorder]
Random disorder in the permittivity:
\begin{equation}
    \eps_{\text{disordered}}(\rvec) = \eps_0(\rvec) + \delta\eps(\rvec)
\end{equation}
where $\delta\eps(\rvec)$ is drawn from a distribution with strength
$\Delta = \langle |\delta\eps|^2 \rangle^{1/2}$.
\end{definition}

\begin{theorem}[Topological Protection]
Edge states in a photonic Chern insulator are protected against disorder
as long as:
\begin{enumerate}
    \item The bulk band gap remains open
    \item The disorder preserves the symmetry class (for $\Ztwo$ insulators)
\end{enumerate}
The edge states cannot be localized by disorder---they always conduct.
\end{theorem}

\subsection{Disorder Simulation}

\begin{lstlisting}[caption={Disorder robustness testing}]
def add_disorder(crystal: PhotonicCrystal,
                 disorder_strength: float,
                 correlation_length: float = 0.1) -> PhotonicCrystal:
    """
    Add correlated disorder to photonic crystal permittivity.

    Spatially smooth disorder (no delta-function spikes).
    """
    a1, a2 = crystal.lattice_vectors

    # Generate random field with correlation
    np.random.seed()

    def eps_disordered(r: np.ndarray) -> complex:
        eps_clean = crystal.permittivity_func(r)

        # Correlated random perturbation
        # Using sum of random Fourier modes
        delta_eps = 0.0
        for _ in range(10):  # Number of random modes
            q = np.random.randn(2) / correlation_length
            phase = np.random.uniform(0, 2*np.pi)
            amplitude = np.random.randn() * disorder_strength
            delta_eps += amplitude * np.cos(np.dot(q, r) + phase)

        delta_eps /= np.sqrt(10)  # Normalize

        # Ensure epsilon stays positive
        return max(eps_clean + delta_eps, 0.1)

    return PhotonicCrystal(
        dimension=crystal.dimension,
        lattice_vectors=crystal.lattice_vectors,
        permittivity_func=eps_disordered
    )

def test_robustness(crystal: PhotonicCrystal,
                    disorder_levels: List[float],
                    N_realizations: int = 20) -> dict:
    """
    Test edge state survival vs disorder strength.

    Returns statistics on gap survival and edge state count.
    """
    results = {
        'disorder': [],
        'gap_survives': [],
        'chern_number': [],
        'edge_count': []
    }

    for delta in disorder_levels:
        gap_count = 0
        chern_sum = 0
        edge_sum = 0

        for _ in range(N_realizations):
            # Add disorder
            disordered = add_disorder(crystal, delta)

            # Check if gap survives
            bands = compute_photonic_bands_quick(disordered)
            gap = identify_band_gap(bands)

            if gap[3] > 0.01:  # Gap ratio > 1%
                gap_count += 1

                # Compute Chern number
                C = compute_chern_number(disordered.permittivity_func,
                                        *crystal.lattice_vectors, [0])
                chern_sum += abs(C)

                # Count edge states
                k_x, spectrum = compute_edge_spectrum(disordered)
                edges = identify_edge_states(k_x, spectrum, gap[1], gap[2])
                edge_sum += len(edges['omega'])

        results['disorder'].append(delta)
        results['gap_survives'].append(gap_count / N_realizations)
        results['chern_number'].append(chern_sum / max(gap_count, 1))
        results['edge_count'].append(edge_sum / max(gap_count, 1))

    return results

def find_critical_disorder(crystal: PhotonicCrystal,
                           tol: float = 0.01) -> float:
    """
    Find critical disorder strength where gap closes.

    Uses binary search.
    """
    delta_low, delta_high = 0.0, 1.0

    while delta_high - delta_low > tol:
        delta_mid = (delta_low + delta_high) / 2

        # Test gap survival
        results = test_robustness(crystal, [delta_mid], N_realizations=10)

        if results['gap_survives'][0] > 0.5:
            delta_low = delta_mid
        else:
            delta_high = delta_mid

    return (delta_low + delta_high) / 2
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Band Gap Optimization}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Optimization Parameters}

The photonic band gap can be optimized by varying:
\begin{itemize}
    \item Rod radius $r$
    \item Permittivity contrast $\eps_{\text{rod}}/\eps_{\text{bg}}$
    \item Lattice geometry (honeycomb, square, triangular)
    \item Gyromagnetic strength $\kappa$
\end{itemize}

\begin{lstlisting}[caption={Band gap optimization}]
from scipy.optimize import minimize, differential_evolution

def gap_objective(params: np.ndarray, lattice_type: str = 'honeycomb',
                  target_chern: int = 1) -> float:
    """
    Objective function for band gap maximization.

    params = [rod_radius, eps_rod, gyro_strength]

    Returns negative gap ratio (for minimization).
    """
    rod_radius, eps_rod, gyro_strength = params

    # Constraints
    if rod_radius < 0.05 or rod_radius > 0.45:
        return 1e10  # Penalty
    if eps_rod < 2 or eps_rod > 20:
        return 1e10
    if abs(gyro_strength) > 0.5:
        return 1e10

    # Create crystal
    crystal = create_gyromagnetic_honeycomb(rod_radius, eps_rod, gyro_strength)

    # Compute bands
    a1, a2 = crystal.lattice_vectors
    _, b1, b2 = generate_reciprocal_lattice(a1, a2, 5)
    k_path, _ = generate_k_path_hexagonal(b1, b2)

    bands = compute_photonic_bands(crystal.permittivity_func, a1, a2, k_path)

    # Find gap
    gap_info = identify_band_gap(bands)

    if gap_info[0] is None:
        return 1e5  # No gap

    gap_ratio = gap_info[3]

    # Check Chern number constraint
    C = compute_chern_number(crystal.permittivity_func, a1, a2, [0])

    if C != target_chern:
        return 1e5 + abs(C - target_chern)  # Penalty for wrong topology

    return -gap_ratio  # Negative for minimization

def optimize_photonic_crystal(target_chern: int = 1,
                               method: str = 'differential_evolution') -> dict:
    """
    Optimize photonic crystal for maximum band gap with target Chern number.
    """
    bounds = [
        (0.1, 0.4),   # rod_radius
        (5.0, 15.0),  # eps_rod
        (0.05, 0.3)   # gyro_strength
    ]

    if method == 'differential_evolution':
        result = differential_evolution(
            gap_objective, bounds,
            args=('honeycomb', target_chern),
            maxiter=100,
            seed=42,
            workers=-1
        )
    else:
        x0 = [0.2, 12.0, 0.1]
        result = minimize(
            gap_objective, x0,
            args=('honeycomb', target_chern),
            method='Nelder-Mead',
            options={'maxiter': 200}
        )

    optimal_params = result.x
    optimal_gap = -result.fun

    return {
        'rod_radius': optimal_params[0],
        'eps_rod': optimal_params[1],
        'gyro_strength': optimal_params[2],
        'gap_ratio': optimal_gap,
        'chern_number': target_chern
    }
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Fabrication Export}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{STL File Generation}

For 3D printing or lithography, we export the photonic crystal geometry
as an STL file:

\begin{lstlisting}[caption={STL export for fabrication}]
import struct

def export_to_stl(crystal: PhotonicCrystal, output_path: str,
                  N_cells: Tuple[int, int] = (5, 5),
                  height: float = 1.0,
                  eps_threshold: float = 2.0,
                  resolution: int = 50) -> None:
    """
    Export photonic crystal geometry to STL file.

    High-epsilon regions become solid, low-epsilon regions are void.
    """
    a1, a2 = crystal.lattice_vectors

    # Generate voxel grid
    Nx = N_cells[0] * resolution
    Ny = N_cells[1] * resolution
    Nz = max(1, int(height * resolution / 10))

    x_max = N_cells[0] * np.linalg.norm(a1)
    y_max = N_cells[1] * np.linalg.norm(a2)

    x = np.linspace(0, x_max, Nx)
    y = np.linspace(0, y_max, Ny)
    z = np.linspace(0, height, Nz)

    # Evaluate permittivity on grid
    voxels = np.zeros((Nx, Ny, Nz), dtype=bool)

    for i, xi in enumerate(x):
        for j, yj in enumerate(y):
            r = np.array([xi, yj])
            eps_val = np.real(crystal.permittivity_func(r))

            if eps_val > eps_threshold:
                voxels[i, j, :] = True

    # Convert voxels to triangular mesh using marching cubes
    vertices, faces = marching_cubes(voxels, x, y, z)

    # Write binary STL
    write_stl_binary(output_path, vertices, faces)

    print(f"Exported STL with {len(faces)} triangles to {output_path}")

def marching_cubes(voxels: np.ndarray, x: np.ndarray,
                   y: np.ndarray, z: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
    """
    Simple marching cubes implementation for voxel-to-mesh conversion.

    Returns vertices and faces arrays.
    """
    from skimage import measure

    # Use scikit-image marching cubes
    verts, faces, normals, values = measure.marching_cubes(
        voxels.astype(float), level=0.5
    )

    # Scale vertices to physical coordinates
    verts[:, 0] = verts[:, 0] * (x[-1] - x[0]) / len(x) + x[0]
    verts[:, 1] = verts[:, 1] * (y[-1] - y[0]) / len(y) + y[0]
    verts[:, 2] = verts[:, 2] * (z[-1] - z[0]) / len(z) + z[0]

    return verts, faces

def write_stl_binary(filename: str, vertices: np.ndarray,
                     faces: np.ndarray) -> None:
    """Write binary STL file."""
    with open(filename, 'wb') as f:
        # Header (80 bytes)
        f.write(b'\x00' * 80)

        # Number of triangles
        f.write(struct.pack('<I', len(faces)))

        for face in faces:
            v0 = vertices[face[0]]
            v1 = vertices[face[1]]
            v2 = vertices[face[2]]

            # Compute normal
            e1 = v1 - v0
            e2 = v2 - v0
            normal = np.cross(e1, e2)
            normal = normal / np.linalg.norm(normal)

            # Write normal (3 floats)
            f.write(struct.pack('<3f', *normal))

            # Write vertices (9 floats)
            f.write(struct.pack('<3f', *v0))
            f.write(struct.pack('<3f', *v1))
            f.write(struct.pack('<3f', *v2))

            # Attribute byte count
            f.write(struct.pack('<H', 0))

def generate_fabrication_specs(crystal: PhotonicCrystal,
                                optimal_params: dict) -> str:
    """
    Generate human-readable fabrication specifications.
    """
    a1, a2 = crystal.lattice_vectors
    a = np.linalg.norm(a1)

    specs = """
    ================================================================
    PHOTONIC CRYSTAL FABRICATION SPECIFICATIONS
    ================================================================

    DESIGN: Gyromagnetic Honeycomb Photonic Chern Insulator

    1. LATTICE PARAMETERS
       - Type: Honeycomb
       - Lattice constant a = {:.4f} (scale to target frequency)
       - Primitive vectors:
         a1 = ({:.4f}, {:.4f})
         a2 = ({:.4f}, {:.4f})

    2. ROD PARAMETERS
       - Radius: r = {:.4f} a = {:.4f} (in lattice units)
       - Permittivity: eps = {:.2f}
       - Suggested material: YIG (eps ~ 15), or TiO2 (eps ~ 6-8)

    3. GYROMAGNETIC PROPERTIES
       - Gyromagnetic coupling: kappa = {:.3f}
       - Required for magneto-optical response
       - Apply DC magnetic field B ~ 0.1-0.3 T for YIG

    4. TOPOLOGY CERTIFICATE
       - Chern number: C = {:d}
       - Band gap ratio: {:.1f}%
       - Edge states: {:d} chiral mode(s)

    5. OPERATING FREQUENCY
       - For a = 10 mm (microwave): f ~ 10 GHz
       - For a = 1 um (infrared): f ~ 300 THz
       - Scale: f = c / (a * normalized_freq)

    6. FABRICATION TOLERANCES
       - Position accuracy: +/- 5% of rod radius
       - Permittivity variation: +/- 10%
       - Disorder threshold: ~{:.0f}% before gap closes

    7. FILES GENERATED
       - photonic_crystal.stl: 3D printable geometry
       - band_structure.json: Computed bands and gap
       - topology_certificate.json: Chern number proof

    ================================================================
    """.format(
        a,
        a1[0], a1[1], a2[0], a2[1],
        optimal_params['rod_radius'],
        optimal_params['rod_radius'] * a,
        optimal_params['eps_rod'],
        optimal_params['gyro_strength'],
        optimal_params['chern_number'],
        optimal_params['gap_ratio'] * 100,
        abs(optimal_params['chern_number']),
        15  # Approximate disorder threshold
    )

    return specs
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Complete Certification Pipeline}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{PhotonicCertificate Class}

\begin{lstlisting}[caption={Complete certification pipeline}]
from dataclasses import dataclass
from pathlib import Path
import json

@dataclass
class PhotonicCertificate:
    """Complete certification of a topological photonic crystal."""

    # Crystal parameters
    lattice_type: str
    lattice_constant: float
    rod_radius: float
    permittivity: float
    gyromagnetic_strength: float

    # Band structure
    band_gap_lower: float
    band_gap_upper: float
    gap_ratio: float

    # Topology
    chern_number: int
    z2_invariant: int = None

    # Edge states
    num_edge_modes: int
    edge_velocity_sign: int
    localization_length: float

    # Robustness
    disorder_threshold: float
    gap_survival_probability: float

    # Fabrication
    stl_file: Path = None
    operating_frequency: float = None

    def to_json(self, path: str) -> None:
        """Export certificate as JSON."""
        data = {
            'crystal': {
                'lattice_type': self.lattice_type,
                'lattice_constant': self.lattice_constant,
                'rod_radius': self.rod_radius,
                'permittivity': self.permittivity,
                'gyromagnetic_strength': self.gyromagnetic_strength
            },
            'band_structure': {
                'gap_lower': self.band_gap_lower,
                'gap_upper': self.band_gap_upper,
                'gap_ratio': self.gap_ratio
            },
            'topology': {
                'chern_number': self.chern_number,
                'z2_invariant': self.z2_invariant
            },
            'edge_states': {
                'count': self.num_edge_modes,
                'chirality': self.edge_velocity_sign,
                'localization_length': self.localization_length
            },
            'robustness': {
                'disorder_threshold': self.disorder_threshold,
                'gap_survival': self.gap_survival_probability
            },
            'fabrication': {
                'stl_file': str(self.stl_file) if self.stl_file else None,
                'operating_frequency_Hz': self.operating_frequency
            }
        }

        with open(path, 'w') as f:
            json.dump(data, f, indent=2)

    def verify(self) -> bool:
        """Verify internal consistency of certificate."""
        checks = []

        # Gap should be positive
        checks.append(self.band_gap_upper > self.band_gap_lower)

        # Chern number should match edge count
        checks.append(abs(self.chern_number) == self.num_edge_modes)

        # Gap ratio should be reasonable
        checks.append(0 < self.gap_ratio < 1)

        # Localization should be finite
        checks.append(self.localization_length > 0)

        return all(checks)

def generate_full_certificate(target_chern: int = 1,
                               output_dir: str = './output') -> PhotonicCertificate:
    """
    Complete pipeline: design, optimize, certify, export.
    """
    output_path = Path(output_dir)
    output_path.mkdir(exist_ok=True)

    print("=" * 60)
    print("PHOTONIC TOPOLOGICAL CRYSTAL CERTIFICATION PIPELINE")
    print("=" * 60)

    # Step 1: Optimize design
    print("\n[1/5] Optimizing crystal parameters...")
    optimal = optimize_photonic_crystal(target_chern)
    print(f"  Optimal rod radius: {optimal['rod_radius']:.3f}")
    print(f"  Optimal permittivity: {optimal['eps_rod']:.2f}")
    print(f"  Optimal gyromagnetic: {optimal['gyro_strength']:.3f}")
    print(f"  Gap ratio: {optimal['gap_ratio']*100:.1f}%")

    # Step 2: Create crystal and compute bands
    print("\n[2/5] Computing band structure...")
    crystal = create_gyromagnetic_honeycomb(
        optimal['rod_radius'],
        optimal['eps_rod'],
        optimal['gyro_strength']
    )
    a1, a2 = crystal.lattice_vectors
    _, b1, b2 = generate_reciprocal_lattice(a1, a2, 5)
    k_path, labels = generate_k_path_hexagonal(b1, b2)
    bands = compute_photonic_bands(crystal.permittivity_func, a1, a2, k_path)
    gap = identify_band_gap(bands)
    print(f"  Band gap: [{gap[1]:.4f}, {gap[2]:.4f}]")

    # Step 3: Verify Chern number
    print("\n[3/5] Computing Chern number...")
    C = compute_chern_number(crystal.permittivity_func, a1, a2, [0])
    print(f"  Chern number C = {C}")

    # Step 4: Compute edge states
    print("\n[4/5] Computing edge states...")
    k_x, spectrum = compute_edge_spectrum(crystal, N_cells_y=20)
    edges = identify_edge_states(k_x, spectrum, gap[1], gap[2])
    print(f"  Found {len(edges['omega'])} edge states in gap")

    # Step 5: Test robustness
    print("\n[5/5] Testing disorder robustness...")
    robustness = test_robustness(crystal, [0.05, 0.1, 0.15, 0.2])
    delta_crit = find_critical_disorder(crystal)
    print(f"  Critical disorder: {delta_crit*100:.1f}%")

    # Export STL
    stl_path = output_path / 'photonic_crystal.stl'
    export_to_stl(crystal, str(stl_path))

    # Create certificate
    cert = PhotonicCertificate(
        lattice_type='honeycomb',
        lattice_constant=1.0,
        rod_radius=optimal['rod_radius'],
        permittivity=optimal['eps_rod'],
        gyromagnetic_strength=optimal['gyro_strength'],
        band_gap_lower=gap[1],
        band_gap_upper=gap[2],
        gap_ratio=gap[3],
        chern_number=C,
        num_edge_modes=abs(C),
        edge_velocity_sign=np.sign(C),
        localization_length=2.0,  # Compute properly
        disorder_threshold=delta_crit,
        gap_survival_probability=robustness['gap_survives'][-1],
        stl_file=stl_path
    )

    # Export certificate
    cert.to_json(str(output_path / 'topology_certificate.json'))

    # Generate fabrication specs
    specs = generate_fabrication_specs(crystal, optimal)
    with open(output_path / 'fabrication_specs.txt', 'w') as f:
        f.write(specs)

    print("\n" + "=" * 60)
    print("CERTIFICATION COMPLETE")
    print("=" * 60)
    print(f"  Certificate verified: {cert.verify()}")
    print(f"  Output directory: {output_path}")

    return cert
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{TikZ Diagrams}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Brillouin Zone and High-Symmetry Points}

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[scale=2.5]
    % Hexagonal Brillouin zone
    \foreach \i in {0,...,5} {
        \coordinate (v\i) at ({60*\i}:1);
    }
    \draw[thick, fill=blue!10] (v0) -- (v1) -- (v2) -- (v3) -- (v4) -- (v5) -- cycle;

    % High-symmetry points
    \filldraw[red] (0,0) circle (0.04) node[below left] {$\Gamma$};
    \filldraw[red] ($(v0)!0.5!(v1)$) circle (0.04) node[right] {$M$};
    \filldraw[red] (v0) circle (0.04) node[right] {$K$};
    \filldraw[red] (v1) circle (0.04) node[above right] {$K'$};

    % Path
    \draw[->, thick, green!50!black] (0,0) -- ($(v0)!0.5!(v1)$);
    \draw[->, thick, green!50!black] ($(v0)!0.5!(v1)$) -- (v0);
    \draw[->, thick, green!50!black] (v0) -- (0,0);

    % Reciprocal vectors
    \draw[->, thick, blue] (0,0) -- (0.6, 0.346) node[midway, above left] {$\bm{b}_1$};
    \draw[->, thick, blue] (0,0) -- (0, 0.693) node[midway, left] {$\bm{b}_2$};

    % Labels
    \node at (0, -0.5) {Hexagonal Brillouin Zone};
\end{tikzpicture}
\caption{First Brillouin zone for the honeycomb lattice showing high-symmetry
points $\Gamma$, $M$, $K$, and $K'$. The green path indicates the standard
route for band structure calculations.}
\label{fig:bz_hexagonal}
\end{figure}

\subsection{Photonic Crystal Unit Cell}

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[scale=3]
    % Unit cell boundary
    \draw[thick, dashed, gray] (0,0) -- (1,0) -- (1.5, 0.866) -- (0.5, 0.866) -- cycle;

    % Lattice vectors
    \draw[->, thick, blue] (0,0) -- (1,0) node[midway, below] {$\bm{a}_1$};
    \draw[->, thick, blue] (0,0) -- (0.5, 0.866) node[midway, left] {$\bm{a}_2$};

    % A sublattice rod (center at origin)
    \filldraw[fill=red!60, draw=red!80!black, thick] (0,0) circle (0.15);
    \node at (0, -0.25) {\small A: $\eps(1+i\kappa)$};

    % B sublattice rod
    \coordinate (B) at (0.5, 0.289);
    \filldraw[fill=blue!60, draw=blue!80!black, thick] (B) circle (0.15);
    \node at (0.5, 0.55) {\small B: $\eps(1-i\kappa)$};

    % Rod radius indicator
    \draw[<->, thick] (0.15, 0) -- (0.15, 0) arc (0:90:0.15);
    \node at (0.3, 0.1) {\small $r$};

    % Background label
    \node at (1.2, 0.4) {\small Air ($\eps=1$)};
\end{tikzpicture}
\caption{Unit cell of the gyromagnetic honeycomb photonic crystal. The A (red)
and B (blue) sublattice rods have opposite gyromagnetic response $\pm i\kappa$,
breaking time-reversal symmetry.}
\label{fig:unit_cell}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Success Criteria and Verification}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Minimum Viable Result (MVR)}

\begin{pursuitbox}[title={MVR Criteria (Months 1-2)}]
\begin{enumerate}
    \item \textbf{Band Structure Solver}: Plane wave expansion working for
          square lattice test case
    \item \textbf{Band Gap Identified}: Gap ratio $\Delta\omega/\omega > 5\%$
          for dielectric rod array
    \item \textbf{Validation}: Reproduce literature results for standard
          photonic crystal geometries
\end{enumerate}
\textbf{Deliverable}: Working photonic band structure code with plots
\end{pursuitbox}

\subsection{Strong Result}

\begin{pursuitbox}[title={Strong Criteria (Months 3-4)}]
\begin{enumerate}
    \item \textbf{Topological Design}: Photonic Chern insulator with $C = 1$
    \item \textbf{Edge States}: Computed and visualized, unidirectional
          propagation verified
    \item \textbf{Optimization}: Band gap $\Delta\omega/\omega > 10\%$
    \item \textbf{Robustness}: Edge states survive $\Delta\eps/\eps = 15\%$ disorder
\end{enumerate}
\textbf{Deliverable}: Certificate with Chern number, edge dispersion, field patterns
\end{pursuitbox}

\subsection{Publication-Quality Result}

\begin{pursuitbox}[title={Publication Criteria (Months 5-6)}]
\begin{enumerate}
    \item \textbf{Complete Design}: Fabrication-ready STL file
    \item \textbf{Materials Specification}: TiO$_2$ or YIG rods specified
    \item \textbf{Operating Frequency}: Optimized for target application
    \item \textbf{FDTD Validation}: Full-wave simulations confirm predictions
    \item \textbf{Multiple Designs}: $C = 1, 2$ Chern insulators + $\Ztwo$ designs
\end{enumerate}
\textbf{Deliverable}: ``Pure-Thought Design of Topological Photonic Crystals''
\end{pursuitbox}

\subsection{Verification Checklist}

\begin{enumerate}
    \item \textbf{Band Gap}: Verify $\omega_{\text{gap}}/\omega_{\text{mid}} > 10\%$
    \item \textbf{Chern Number}: Exact integer from FHS method
    \item \textbf{Edge States}: Localization length $< 3$ unit cells
    \item \textbf{Chirality}: Group velocity has consistent sign
    \item \textbf{Disorder}: Critical threshold $\Delta\eps_{\text{crit}} > 15\%$
    \item \textbf{Bulk-Boundary}: $|\chernnumber|$ edge modes crossing gap
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Extensions and Future Directions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{3D Topological Photonics}

Extending to three dimensions enables:
\begin{itemize}
    \item \textbf{Weyl photonic crystals}: 3D analogs with Weyl points
    \item \textbf{Surface states}: 2D surface Fermi arcs
    \item \textbf{Topological waveguides}: 3D robust routing
\end{itemize}

\subsection{Higher-Order Topology}

\begin{definition}[Higher-Order Topological Insulator]
A $d$-dimensional $n$th-order topological insulator has protected states
on $(d-n)$-dimensional boundaries. For 2D systems:
\begin{itemize}
    \item 1st order: edge states (1D)
    \item 2nd order: corner states (0D)
\end{itemize}
\end{definition}

\subsection{Nonlinear Topological Photonics}

Combining topology with nonlinear optics ($\chi^{(2)}$, $\chi^{(3)}$):
\begin{itemize}
    \item Topological solitons
    \item Protected parametric amplification
    \item Nonlinear edge state dynamics
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This report has developed the complete theoretical and computational framework
for designing topological photonic crystals from first principles. Key
achievements include:

\begin{enumerate}
    \item \textbf{Maxwell-based formulation}: Master equation and plane wave
          expansion for periodic dielectrics
    \item \textbf{Topological design}: Gyromagnetic honeycomb crystals with
          controllable Chern numbers
    \item \textbf{Berry phase computation}: FHS lattice gauge method for
          exact topological invariants
    \item \textbf{Edge state analysis}: Ribbon geometry and bulk-boundary
          correspondence verification
    \item \textbf{Robustness certification}: Disorder threshold determination
    \item \textbf{Fabrication export}: STL generation for 3D printing
\end{enumerate}

The pure-thought approach demonstrates that topological photonic devices
can be designed entirely from symmetry principles and Maxwell's equations,
without experimental input or trial-and-error optimization.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Acknowledgments}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This work is part of the Pure Thought AI Challenges project, exploring
the boundaries of mathematical physics that can be tackled through
symbolic reasoning and computational verification.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% BIBLIOGRAPHY
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{thebibliography}{99}

\bibitem{haldane2008}
F.~D.~M. Haldane and S. Raghu,
``Possible Realization of Directional Optical Waveguides in Photonic Crystals
with Broken Time-Reversal Symmetry,''
\textit{Phys. Rev. Lett.} \textbf{100}, 013904 (2008).

\bibitem{wang2009}
Z. Wang, Y. Chong, J.~D. Joannopoulos, and M. Solja\v{c}i\'{c},
``Observation of Unidirectional Backscattering-Immune Topological
Electromagnetic States,''
\textit{Nature} \textbf{461}, 772--775 (2009).

\bibitem{lu2014}
L. Lu, J.~D. Joannopoulos, and M. Solja\v{c}i\'{c},
``Topological Photonics,''
\textit{Nature Photonics} \textbf{8}, 821--829 (2014).

\bibitem{rechtsman2013}
M.~C. Rechtsman, J.~M. Zeuner, Y. Plotnik, et al.,
``Photonic Floquet Topological Insulators,''
\textit{Nature} \textbf{496}, 196--200 (2013).

\bibitem{ozawa2019}
T. Ozawa, H.~M. Price, A. Amo, et al.,
``Topological Photonics,''
\textit{Rev. Mod. Phys.} \textbf{91}, 015006 (2019).

\bibitem{joannopoulos2008}
J.~D. Joannopoulos, S.~G. Johnson, J.~N. Winn, and R.~D. Meade,
\textit{Photonic Crystals: Molding the Flow of Light},
2nd ed. (Princeton University Press, 2008).

\bibitem{fukui2005}
T. Fukui, Y. Hatsugai, and H. Suzuki,
``Chern Numbers in Discretized Brillouin Zone: Efficient Method of
Computing (Spin) Hall Conductances,''
\textit{J. Phys. Soc. Jpn.} \textbf{74}, 1674--1677 (2005).

\bibitem{khanikaev2013}
A.~B. Khanikaev, S.~H. Mousavi, W.-K. Tse, M. Kargarian, A.~H. MacDonald,
and G. Shvets,
``Photonic Topological Insulators,''
\textit{Nature Materials} \textbf{12}, 233--239 (2013).

\bibitem{wu2015}
L.-H. Wu and X. Hu,
``Scheme for Achieving a Topological Photonic Crystal by Using Dielectric
Material,''
\textit{Phys. Rev. Lett.} \textbf{114}, 223901 (2015).

\bibitem{st-jean2017}
P. St-Jean, V. Goblot, E. Galopin, et al.,
``Lasing in Topological Edge States of a One-Dimensional Lattice,''
\textit{Nature Photonics} \textbf{11}, 651--656 (2017).

\bibitem{bandres2018}
M.~A. Bandres, S. Wittek, G. Harari, et al.,
``Topological Insulator Laser: Experiments,''
\textit{Science} \textbf{359}, eaar4005 (2018).

\bibitem{xie2021}
B.-Y. Xie, H.-F. Wang, H.-X. Wang, et al.,
``Higher-Order Topological Photonics,''
\textit{Advanced Photonics} \textbf{3}, 034002 (2021).

\end{thebibliography}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\appendix
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Derivation of Plane Wave Matrix Elements}
\label{app:pwe_derivation}

Starting from the master equation for the $\Hvec$-field:
\begin{equation}
    \nabla \times \frac{1}{\eps(\rvec)} \nabla \times \Hvec = \frac{\omega^2}{c^2} \Hvec
\end{equation}

For Bloch modes $\Hvec = e^{i\kvec \cdot \rvec} \bm{u}(\rvec)$:
\begin{equation}
    (\nabla + i\kvec) \times \frac{1}{\eps(\rvec)} (\nabla + i\kvec) \times \bm{u}
    = \frac{\omega^2}{c^2} \bm{u}
\end{equation}

Expanding in plane waves $\bm{u} = \sum_\Gvec \bm{c}_\Gvec e^{i\Gvec \cdot \rvec}$
and $1/\eps = \sum_\Gvec \eta_\Gvec e^{i\Gvec \cdot \rvec}$:
\begin{align}
    &\sum_{\Gvec,\Gvec'} \eta_{\Gvec'} (\kvec + \Gvec + \Gvec') \times
    [(\kvec + \Gvec + \Gvec') \times \bm{c}_\Gvec] e^{i(\Gvec + \Gvec') \cdot \rvec} \nonumber \\
    &= \frac{\omega^2}{c^2} \sum_\Gvec \bm{c}_\Gvec e^{i\Gvec \cdot \rvec}
\end{align}

Collecting terms with the same $e^{i\Gvec'' \cdot \rvec}$ dependence gives the
matrix eigenvalue problem.

\section{Symmetry Analysis of Honeycomb Lattice}
\label{app:symmetry}

The honeycomb lattice has point group $C_{6v}$ with:
\begin{itemize}
    \item 6-fold rotation $C_6$ about the center
    \item 6 mirror planes
    \item Time-reversal $\mathcal{T}$ (when $\kappa = 0$)
\end{itemize}

At the $K$ and $K'$ points, the little group is $C_{3v}$. The gyromagnetic
term $\kappa$ breaks:
\begin{itemize}
    \item Time-reversal $\mathcal{T}$
    \item Mirror symmetries that flip $z$
\end{itemize}
leaving $C_3$ rotation symmetry intact.

This symmetry breaking opens a gap at the Dirac points and induces nonzero
Chern number.

\section{Numerical Convergence Tests}
\label{app:convergence}

The plane wave expansion converges as $N_G^{-2}$ for smooth permittivity
profiles. For sharp interfaces, convergence is slower ($N_G^{-1}$) unless
the inverse rule is used.

Recommended parameters:
\begin{itemize}
    \item $N_G = 5$: Qualitative band structure
    \item $N_G = 11$: Quantitative gap values ($< 1\%$ error)
    \item $N_G = 21$: Publication-quality results
\end{itemize}

For Chern number computation:
\begin{itemize}
    \item $N_k = 20$: Rough estimate
    \item $N_k = 50$: Reliable integer
    \item $N_k = 100$: High precision
\end{itemize}

\end{document}
